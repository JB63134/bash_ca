#!/usr/bin/env bash
#------------------------------------------------------------------------
# ta  aka .bash_ta           ┌──────┐ │      │ └──────┘
# Main Function: ta                                                                         
# Purpose: threat assessment
#------------------------------------------------------------------------
# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

# shellcheck disable=SC2034
ta_needed_deps=(grep basename file find sed cut head readlink realpath awk ldd getcap perl)
# shellcheck disable=SC2034
ta_optional_deps=(tput fzf batcat bat dpkg rpm pacman)

OLD_PATH="$PATH"

declare -g __TA_SOURCED_SCANNED=0
declare -gA __TA_SOURCED_FILES_MAP=()    
declare -ga __TA_SOURCED_FILES_LIST=()  
complete -F _ta_completion ta

ta() {
    # -------------------------
    # LOCAL Variables
    # -------------------------
    local fcmd cmd RED GREEN CYAN RESET 
    local depth=${2:-0}
    local MAX_DEPTH=8
    local indent
    indent=$(printf "%*s" $((depth * 4)) "")
    # shellcheck disable=SC2034
    local ctype cmd_path
    
    
    # -------------------------
    # Colors (tput → ANSI → none)
    # -------------------------
    if command -v tput &>/dev/null && [[ $(tput colors 2>/dev/null) -ge 8 ]]; then
        # Preferred: tput colors
        RED=$(tput setaf 1)
        GREEN=$(tput setaf 2)
        CYAN=$(tput setaf 6)
        YELLOW=$(tput setaf 11)
        BPURP=$(tput setaf 13)
        RESET=$(tput sgr0)
        UNLINE=$(tput smul)
        STOPUNLINE=$(tput rmul)
    else
        # Fallback: ANSI escape sequences
        RED='\033[31m'
        GREEN='\033[32m'
        CYAN='\033[36m'
        YELLOW='\033[93m'
        BPURP='\033[95m'
        RESET='\033[0m'
        UNLINE='\033[4m'
        STOPUNLINE='\033[0m'
    fi
 
    : "${RED:=}"
    : "${GREEN:=}"
    : "${CYAN:=}"
    : "${YELLOW:=}"
    : "${BPURP:=}"
    : "${RESET:=}"
    : "${UNLINE:=}"
    : "${STOPUNLINE:=}"
 
    # -------------------------
    # Set first run variables path etc... keep from running every recursive loop 
    # set new path, clean arrays, and greet user once
    # -------------------------
    if (( depth == 0 )); then
        trap '_ta_restore_path' RETURN
        _ta_add_admin_paths

        #--------------------------
        # Reset arrays on first run
        #--------------------------
        __TA_SOURCED_SCANNED=0

        #--------------------------
        # Greeting
        #--------------------------
        printf "\n╔══════════════════════════════════════════════╗\n"
        printf "║  ta – Bash Threat assessment                 ║\n"
        printf "╚══════════════════════════════════════════════╝\n"
        
        # -------------------------
        # Check dependencies
        _ta_check_dependencies ta_needed_deps ta_optional_deps 1  || return 1 # 1 = exit if required deps missing
    fi 
    
    # -------------------------
    # Depth guard
    # -------------------------
    (( depth > MAX_DEPTH )) && { 
        printf "%s${RED}Max recursion depth (%d) reached${RESET}\n" "$indent" "$MAX_DEPTH"
        return 1 
    }
    
    # -------------------------
    # Get command or last command
    # -------------------------
    if [[ -n "$1" ]]; then
        read -r -a fcmd <<< "$1"
    fi
    cmd="${fcmd[0]}"
    
    # -------------------------------------------------------------------------
    # handle arguments for ta
    # -------------------------------------------------------------------------
    case "$cmd" in
        -h|--help) _ta_usage; return 0;;
        -v|--version) _ta_ver; return 0;;
        -t|--threat) printf "\n"; _ta_display_sxid_scan; return 0;;
    esac
    
    # -------------------------------------------------------------------------
    # Handle ta for now, prevent ta from analyzing itself because 
    # it will spam the screen with itself
    # -------------------------------------------------------------------------
    if [[ "$cmd" == "ta" ]]; then
            printf "%s├─ Detected ${CYAN}'%s' ${RESET}\n" "$indent" "$cmd"
            printf "%s    ↳ Showing  ${CYAN}'%s --help'${RESET}:\n\n"  "$indent" "$cmd"
            _ta_usage
            return 0
    fi

    if [[ -z "$cmd" ]]; then
        printf "%s├─ ${RED}Unknown or invalid command:${CYAN} '%s'${RESET}\n" "$indent" "$cmd"
        printf "%s    ↳ Check your spelling and try again\n\n" "$indent" 
        return 1
    fi
}


#------------------------------------------------------------------------
# Function: _ta_usage
# Purpose : Display usage information and examples for the `h` command analyzer.
#------------------------------------------------------------------------
_ta_usage() {
    cat <<'EOF'

     Usage:  ta [command]  

     Options:
           -h --help or h      Show this help text.
           -v --version        Show version information.
           -t --threat         Threat assessment scan of SUID/SGID binaries
                                   and World Writable directories.
           
     Examples:
           ta                   # Automatically analyzes your most recent command

  
EOF
}

#------------------------------------------------------------------------
# Function: _ta_ver
# Purpose : Display version information.
#------------------------------------------------------------------------
_ta_ver() {
    cat <<'EOF'

     ta v1.0.5 — Bash Threat Assessment
     Author : John Blair
          
     MIT License

     Copyright (c) 2025 John Blair

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in all
     copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     SOFTWARE.

EOF
}

#------------------------------------------------------------------------
# Function: _ta_add_admin_paths
# Purpose: Add ~/.local/bin paths safely and temporarily
#------------------------------------------------------------------------
_ta_add_admin_paths() {
    # Save PATH if not already saved 
    if [[ -z "$OLD_PATH" ]]; then
        OLD_PATH="$PATH"
    fi

    local admin_dirs=(
            "$HOME/.local/bin"
            "$HOME/bin/scripts"
            "$HOME/bin"
            "$HOME/.cargo/bin"
            "$HOME/.npm-global/bin"
            "$HOME/.local/share/bash-completion/bin"
            "$BASH_ENV"
            "$CONDA_PREFIX/bin"
            "/flatpak/bin"         
            "/snap/bin"
            "/usr/local/bin"
            "/usr/local/sbin"
            "/usr/local/games"
            "/usr/bin"
            "/usr/sbin"        
            "/usr/games"
            "/bin"
            "/sbin"  
            "/opt/bin"
            "/opt/sbin"         
            )
            
    # Add admin dirs to PATH if missing
    for dir in "${admin_dirs[@]}"; do
        if [[ -d "$dir" && ":$PATH:" != *":$dir:"* ]]; then
            PATH="$PATH:$dir"
        fi
    done
    
    while IFS= read -r d; do
        [[ -d "$d" && ":$PATH:" != *":$d:"* ]] && PATH="$PATH:$d"
    done < <(find "$HOME/.local/bin" -type d 2>/dev/null)
}

#------------------------------------------------------------------------
# Function: _ta_restore_path
# Automatically restore PATH when leaving scope
#------------------------------------------------------------------------
_ta_restore_path() {
    if [[ -n "$OLD_PATH" ]]; then
        PATH="$OLD_PATH"
        unset OLD_PATH
    fi
}

#------------------------------------------------------------------------
# Function: _ta_completion
# Purpose : Enable tab completion for entering commands 
#------------------------------------------------------------------------
_ta_completion() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local commands
    
    trap '_ta_restore_path' RETURN
    _ta_add_admin_paths
    
    # Collect possible completions: aliases, functions, builtins, and executables in PATH
    mapfile -t commands < <(compgen -A function -A alias -A builtin -A command -- "$cur")
    # Provide them to bash-completion
    COMPREPLY=("${commands[@]}")
}

#------------------------------------------------------------------------
# Function: _ta_check_dependencies
# Purpose : Check core and optional dependencies, optionally exit on missing core deps
# Usage   : _ta_check_dependencies needed_deps optional_deps [EXIT_ON_MISSING] 0or1
#------------------------------------------------------------------------
_ta_check_dependencies() {
    local -n required="$1"
    local -n optional="$2"
    local exit_on_missing="${3:-1}"

    local missing_required=()
    local missing_optional=()

    for cmd in "${required[@]}"; do
        command -v "$cmd" >/dev/null 2>&1 || missing_required+=("$cmd")
    done

    for cmd in "${optional[@]}"; do
        command -v "$cmd" >/dev/null 2>&1 || missing_optional+=("$cmd")
    done

    if (( ${#missing_required[@]} )); then
        printf "%b\n" "${RED}Warning: Missing REQUIRED tools: ${missing_required[*]}${RESET}"
        if (( exit_on_missing )); then
            printf "%b\n" "${RED}Cannot continue analysis without core dependencies.${RESET}"
            if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
                exit 1
            else
                return 1
            fi
        fi
    fi

    return 0
}

#------------------------------------------------------------------------
# Function: _ta_display_sxid_scan
# Purpose : scan for SUID / SGID binaries and World-Writable directories 
#------------------------------------------------------------------------
_ta_display_sxid_scan() {
    printf "=== SUID/SGID and W-W directories (Mode: -G) ===\n\n"
    printf "├─ SUID Binaries (Identity Boundary)\n"
    _ta_suid_threat_scan
    printf "├─ SGID Binaries (Group Boundary)\n"
    _ta_sgid_threat_scan
    printf "├─ World-Writable Directories (Writable Path Surfaces)\n"
    _ta_world_writable_scan
    printf "\n================ End of list =================== \n"
}


#------------------------------------------------------------------------
# Function: _ta_suid_threat_scan
# Purpose : Scan for SUID gtfo risk binaries
#------------------------------------------------------------------------
_ta_suid_threat_scan() {
    printf "├─ Scanning -- SUID threat assessment:\n"

while IFS= read -r hit; do
    _ta_threat_analyze_binary "$hit"
done < <(find / -perm -4000 -type f 2>/dev/null)
}

declare -A THREAT_SIGS=(
  # High confidence: trivial or near-trivial exploitation
  [bash]="shell exec|high"
  [sh]="shell exec|high"
  [dash]="shell exec|high"
  [find]="exec file-write|high"
  [perl]="exec shell|high"
  [python]="exec shell|high"
  [nmap]="shell exec|high"
  [socat]="shell exec|high"

  # Medium confidence: common but situational
  [env]="exec path-hijack|medium"
  [awk]="exec|medium"
  [sed]="file-write|medium"
  [tar]="file-write|medium"
  [openssl]="exec file-write|medium"
  [tee]="file-write|medium"
  [cp]="file-write|medium"
  
  # Low confidence: interactive / escape-based
  [less]="shell file-read|low"
  [more]="file-read|low"
  [man]="shell|low"
  [vi]="shell|low"
  [vim]="shell file-read|low"
  [ftp]="shell|low"
)

#-----------------------------------------------------------
# Helper: _ta_threat_detect (SUID)
#-----------------------------------------------------------
_ta_threat_detect() {
    local bin="$1"
    local sig confidence
    local name

    declare -A found=()
    name=$(basename "$bin")

    # ---- known auth-impact binaries ----
    case "$name" in
        su|sudo|passwd|chsh|chfn|newgrp|gpasswd)
            found[modify-auth]=1
            ;;
    esac

    # ---- static signatures ----
    if [[ -n "${THREAT_SIGS[$name]}" ]]; then
        sig="${THREAT_SIGS[$name]}"
        IFS='|' read -r primitives confidence <<< "$sig"
        for p in $primitives; do
            case "$p" in
                shell) found[execute-shell]=1 ;;
                exec) found[execute-command]=1 ;;
                file-read) found[read-file]=1 ;;
                file-write) found[write-file]=1 ;;
                env-inject) found[read-environment]=1 ;;
                path-hijack) found[resolve-path-untrusted]=1 ;;
                user-input) found[accept-constrained-input]=1 ;;
                auth-impact) found[modify-auth]=1 ;;
            esac
        done
        [[ -n "$confidence" ]] && found["confidence:$confidence"]=1
    fi

    # ---- strings-based heuristics ----
    local s
    s=$(strings "$bin" 2>/dev/null)

    grep -qiE 'argv\[|getopt|getopt_long|scanf|fgets|gets' <<<"$s" && found[accept-constrained-input]=1
    grep -qiE 'system\(|execv|execl|popen' <<<"$s" && found[execute-command]=1
    grep -qiE '\b(sh|bash|dash)\b' <<<"$s" && found[execute-shell]=1
    grep -qiE '\-exec\b|\-c\b|system\(' <<<"$s" && found[execute-command]=1
    grep -qiE '\b(open|read|cat|less|more)\b' <<<"$s" && found[read-file]=1
    grep -qiE '\b(write|output|tee|save)\b' <<<"$s" && found[write-file]=1
    grep -qiE 'execvp|system|popen' <<<"$s" && ! grep -qiE 'clearenv|secure_path|setenv.*PATH' <<<"$s" &&
        found[resolve-path-untrusted]=1
    grep -qiE 'EDITOR=|PAGER=|PATH=' <<<"$s" && found[read-environment]=1
    grep -qiE 'set(res)?uid|seteuid|setreuid|setgid|setregid' <<<"$s" && found[drop-privilege]=1

    # ---- normalize internal-only primitives ----
    if [[ -n "${found[drop-privilege]}" ]]; then
        unset 'found[resolve-path-untrusted]'
        unset 'found[execute-shell]'
        unset 'found[execute-command]'
    fi

    [[ -n "${found[execute-shell]}" && -z "${found[accept-constrained-input]}" ]] && {
        unset 'found[execute-shell]'
        found[execute-shell-internal]=1
    }
    [[ -n "${found[execute-command]}" && -z "${found[accept-constrained-input]}" ]] && {
        unset 'found[execute-command]'
        found[execute-command-internal]=1
    }

    # ---- output in fixed order ----
    for k in modify-auth accept-constrained-input execute-shell execute-shell-internal \
             execute-command execute-command-internal execute-command \
             read-file write-file read-environment resolve-path-untrusted \
             confidence:high confidence:medium; do
        [[ -n "${found[$k]}" ]] && printf "%s " "$k"
    done
}

#-----------------------------------------------------------
# Helper: _ta_threat_classify (SUID, factual)
#-----------------------------------------------------------
_ta_threat_classify() {
    local prims="$1"

    # hard rule: no primitives → no observed surface
    [[ -z "$prims" ]] && {
        echo "no-observed-surface"
        return
    }

    local has_auth has_write has_group
    [[ $prims == *modify-auth* ]] && has_auth=1
    [[ $prims == *write-file* ]] && has_write=1
    [[ $prims == *access-group-resource* ]] && has_group=1

    if [[ -n $has_auth && -n $has_write && -n $has_group ]]; then
        echo "modify-identity modify-filesystem modify-group"
    elif [[ -n $has_auth && -n $has_write ]]; then
        echo "modify-identity modify-filesystem"
    elif [[ -n $has_auth && -n $has_group ]]; then
        echo "modify-identity modify-group"
    elif [[ -n $has_write && -n $has_group ]]; then
        echo "modify-filesystem modify-group"
    elif [[ -n $has_auth ]]; then
        echo "modify-identity"
    elif [[ -n $has_write ]]; then
        echo "modify-filesystem"
    elif [[ -n $has_group ]]; then
        echo "modify-group"
    elif [[ $prims == *read-file* || \
            $prims == *execute-shell-internal* || \
            $prims == *execute-command-internal* ]]; then
        echo "read-files"
    elif [[ $prims == *accept-constrained-input* ]]; then
        echo "constrained-surface-exposed"
    else
        echo "no-observed-surface"
    fi
}


#-----------------------------------------------------------
# Helper: _ta_threat_analyze_binary (SUID)
#-----------------------------------------------------------
_ta_threat_analyze_binary() {
    local bin="$1"
    local prims class

    # Detect primitives
    prims=$(_ta_threat_detect "$bin")

    # Classify based on factual primitives
    class=$(_ta_threat_classify "$prims")

    # Output
    printf "   ${CYAN}%s${RESET}\n" "$bin"
    printf "       class: %s\n" "$class"
    printf "       primitives: %s\n\n" "$prims"
}

#------------------------------------------------------------------------
# Function: _ta_sgid_threat_scan
# Purpose : Scan for SGID risk binaries
#------------------------------------------------------------------------
_ta_sgid_threat_scan() {
    printf "├─ Scanning for SGID amplification risk:\n"

    while IFS= read -r hit; do
        _ta_sgid_threat_analyze_binary "$hit"
    done < <(find / -perm -2000 -type f 2>/dev/null)
}

#-----------------------------------------------------------
# Helper: _ta_sgid_threat_detect (SGID)
#-----------------------------------------------------------
_ta_sgid_threat_detect() {
    local bin="$1"
    local name

    declare -A found=()
    name=$(basename "$bin")

    # ---- detect sensitive group ----
    local gid group
    gid=$(stat -c %g "$bin")
    group=$(getent group "$gid" | cut -d: -f1)
    case "$group" in
        shadow|adm|disk|docker|systemd-journal|utmp)
            found[access-group-resource]=1
            ;;
    esac

    # ---- strings-based heuristics (same as SUID) ----
    local s
    s=$(strings "$bin" 2>/dev/null)

    grep -qiE 'argv\[|getopt|getopt_long|scanf|fgets|gets' <<<"$s" && found[accept-constrained-input]=1
    grep -qiE 'system\(|execv|execl|popen' <<<"$s" && found[execute-command]=1
    grep -qiE '\b(sh|bash|dash)\b' <<<"$s" && found[execute-shell]=1
    grep -qiE '\b(open|read|cat|less|more)\b' <<<"$s" && found[read-file]=1
    grep -qiE '\b(write|output|tee|save)\b' <<<"$s" && found[write-file]=1
    grep -qiE 'EDITOR=|PAGER=|PATH=' <<<"$s" && found[read-environment]=1
    grep -qiE 'setgid|setregid' <<<"$s" && found[drop-privilege]=1

    # ---- normalize internal-only primitives ----
    if [[ -n "${found[drop-privilege]}" ]]; then
        unset 'found[execute-shell]'
        unset 'found[execute-command]'
    fi
    [[ -n "${found[execute-shell]}" && -z "${found[accept-constrained-input]}" ]] && {
        unset 'found[execute-shell]'
        found[execute-shell-internal]=1
    }
    [[ -n "${found[execute-command]}" && -z "${found[accept-constrained-input]}" ]] && {
        unset 'found[execute-command]'
        found[execute-command-internal]=1
    }

    # ---- output in fixed order ----
    local key out=()
    for key in access-group-resource accept-constrained-input execute-shell execute-shell-internal \
               execute-command execute-command-internal execute-command \
               read-file write-file read-environment resolve-path-untrusted \
               confidence:high confidence:medium; do
        [[ -n "${found[$key]}" ]] && out+=("$key")
    done

    printf '%s ' "${out[@]}"
    echo
}

#-----------------------------------------------------------
# Helper: _ta_sgid_threat_analyze_binary (SGID)
#-----------------------------------------------------------
_ta_sgid_threat_analyze_binary() {
    local bin="$1"
    local prims class
    local gid group

    # Detect primitives
    prims=$(_ta_sgid_threat_detect "$bin")

    # Classify based on factual primitives
    class=$(_ta_sgid_threat_classify "$prims")

    # Retrieve group info
    gid=$(stat -c %g "$bin")
    group=$(getent group "$gid" | cut -d: -f1)

    # Output
    printf "   ${CYAN}%s${RESET}\n" "$bin"
    printf "       class: %s\n" "$class"
    printf "       group: %s\n" "$group"
    printf "       primitives: %s\n\n" "$prims"
}

#-----------------------------------------------------------
# Helper: _ta_sgid_threat_classify (SGID, factual)
#-----------------------------------------------------------
_ta_sgid_threat_classify() {
    local prims="$1"

    local has_write has_group
    [[ $prims == *write-file* ]] && has_write=1
    [[ $prims == *access-group-resource* ]] && has_group=1

    if [[ -n $has_write && -n $has_group ]]; then
        echo "filesystem-and-group-modifying"
    elif [[ -n $has_group ]]; then
        echo "group-modifying"
    elif [[ -n $has_write ]]; then
        echo "filesystem-modifying"
    elif [[ $prims == *read-file* || $prims == *read-environment* ]]; then
        echo "read-only"
    else
        echo "constrained-surface-exposed"
    fi
}


#-----------------------------------------------------------
# Function: _ta_world_writable_scan
# Purpose : Identify world-writable directories as injection surfaces
#-----------------------------------------------------------
_ta_world_writable_scan() {
    local dir perms owner group prims class

    printf "├─ Scanning for World-Writable directories:\n"

    local scan_dirs=("/tmp" "/var/tmp" "/run" "/dev/shm")

    for root in "${scan_dirs[@]}"; do
        [ -d "$root" ] || continue
        while IFS= read -r dir; do
            prims=()

            perms=$(stat -c "%A" "$dir" 2>/dev/null)
            owner=$(stat -c "%U" "$dir" 2>/dev/null)
            group=$(stat -c "%G" "$dir" 2>/dev/null)

            prims+=(allow-world-write)

            if [[ "$perms" == *t ]]; then
                prims+=(enforce-sticky-bit)
            else
                prims+=(no-enforce-sticky-bit)
            fi

            [[ "$owner" == "root" ]] && prims+=(own-by-root)

            case "$dir" in
                /tmp|/run/*|/dev/shm*)
                    prims+=(scope-runtime)
                    ;;
                *)
                    prims+=(persist-on-filesystem)
                    ;;
            esac

            prims+=(follow-symlink-path)

            if grep -qE "(^|:)$dir(:|$)" <<<"$PATH"; then
                prims+=(path-inject)
            fi

            # ---- classification rules ----
if [[ " ${prims[*]} " == *" no-enforce-sticky-bit "* && " ${prims[*]} " == *" persist-on-filesystem "* ]]; then
    class="persist-on-filesystem-unprotected"
elif [[ " ${prims[*]} " == *" consume-path "* ]]; then
    class="execution-influencing"
else
    class="confine-runtime"
fi



            printf "   ${CYAN}%s${RESET}\n" "$dir"
            printf "       class: %s\n" "$class"
            printf "       owner: %s:%s\n" "$owner" "$group"
            printf "       perms: %s\n" "$perms"
            printf "       primitives: %s\n\n" "${prims[*]}"

        done < <(find "$root" -type d -perm -0002 2>/dev/null | sort -u)
    done
}
#-----------------------------------------------------------
# Helper: _ta_world_writable_analyze (world-writable dirs)
#-----------------------------------------------------------
_ta_world_writable_analyze() {
    local dir="$1"
    local prims class perms owner group

    perms=$(stat -c "%A" "$dir" 2>/dev/null)
    owner=$(stat -c "%U" "$dir" 2>/dev/null)
    group=$(stat -c "%G" "$dir" 2>/dev/null)

    prims=(allow-world-write)

    [[ "$perms" == *t ]] && prims+=(enforce-sticky-bit) || prims+=(no-enforce-sticky-bit)
    [[ "$owner" == "root" ]] && prims+=(own-by-root)

    case "$dir" in
        /tmp|/run/*|/dev/shm*) prims+=(scope-runtime) ;;
        *) prims+=(persist-on-filesystem) ;;
    esac

    prims+=(follow-symlink-path)

    [[ ":$PATH:" == *":$dir:"* ]] && prims+=(consume-path)

    # Classification
    if [[ " ${prims[*]} " == *" no-enforce-sticky-bit "* && " ${prims[*]} " == *" persist-on-filesystem "* ]]; then
        class="persist-on-filesystem-unprotected"
    elif [[ " ${prims[*]} " == *" consume-path "* ]]; then
        class="execution-influencing"
    else
        class="runtime-contained"
    fi

    # Output
    printf "   ${CYAN}%s${RESET}\n" "$dir"
    printf "       class: %s\n" "$class"
    printf "       owner: %s:%s\n" "$owner" "$group"
    printf "       perms: %s\n" "$perms"
    printf "       primitives: %s\n\n" "${prims[*]}"
}

#------------------------------------------------------------------------
# End of script
