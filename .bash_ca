#!/usr/bin/env bash
#-----------------------------------------------------------------------------------------------
# Command Analyzer
# Main Function: ca                                                                         
# Purpose: Analyzes a Bash command, alias, builtin, keyword,  function, or binary
#          Insepect $PATH order, sourced files, enviromental variables, aliases, and functions.  
#-----------------------------------------------------------------------------------------------
# Copyright (c) 2025 John Blair
# Licensed under the MIT License. See LICENSE file for details.        
#-----------------------------------------------------------------------------------------------
__CA_version="2.1.5"
# shellcheck disable=SC2034
__CA_needed_deps=(grep basename file find bc sed cut head readlink realpath awk ldd getcap perl)
# shellcheck disable=SC2034
__CA_optional_deps=(tput fzf batcat bat dpkg rpm pacman)
__CA_OLD_PATH="$PATH"
__CA_extglob_was=0
__CA_RHEL_like=0

declare -g CA_MAX_DEPTH=5
declare -g __CA_SOURCED_SCANNED=0
declare -gA __CA_SOURCED_FILES_MAP=()    
declare -ga __CA_SOURCED_FILES_LIST=()  

complete -F _ca_completion ca

ca() {
    # If not running interactively, don't do anything
    case $- in
        *i*) ;;
        *) return;;
    esac

    # -------------------------
    # LOCAL Variables
    # -------------------------
    local cmd fcmd ctype depth cmd_path RED GREEN CYAN RESET 
    local verbose=0
    depth=0
        
    trap '_ca_restore_path; _ca_reset_extglob' RETURN

    _ca_detect_os
    _ca_add_admin_paths
    _ca_enable_extglob
    _ca_setup_colors # Setup tput or ansi
    _ca_check_dependencies __CA_needed_deps __CA_optional_deps 1  || return 1 # 1 = exit if required deps missing

    # -------------------------
    # Get command or last command
    # -------------------------
    if [[ -n "$1" ]]; then
        read -r -a fcmd <<< "$@"
    else
        _ca_usage
        return 0
    fi
    cmd="${fcmd[0]}"
    # -------------------------------------------------------------------------
    # handle options
    # -------------------------------------------------------------------------
    case "$cmd" in
        -h|--help) _ca_usage; return 0;;
        --version) _ca_ver; return 0;;
        -o|--overridden) _ca_conflicts; return 0;;   
        -a|--alias) _ca_aliases; return 0;;  
        -f|--function) _ca_function; return 0;;
        -F|--functionv) verbose=1; _ca_function; return 0;;    
        -d|--diff) _ca_bash_option_diff; return 0;;   
        -e|--env) _ca_list_env; return 0;;
        -s|--sourced) _ca_sourced_files; return 0;;
        -p|--path) _ca_writable_dir_in_path; return 0;;   
        -u|--user) _ca_list_user_bin; return 0;;
        -S|--scan) _ca_display_files_scan; return 0;;
        -v|--verify) 
            shift
            [[ -z $1 ]] && { printf "verify requires an argument\n" >&2; return 1; }
            _ca_verify_binary "$1"
            return 0
            ;;  
        -r|--report)
            shift
            [[ -z $1 ]] && { printf "report requires an argument\n" >&2; return 1; }
            ca "$1" &&
            _ca_verify_binary "$1"
            return 0
            ;;              
        --fzf) _ca_fzf_search; return 0;; #alias caf='command -v fzf >/dev/null 2>&1 && ca --fzf || ca' 
    esac
    
    if [[ "$cmd" == "ca" ]]; then 
        _ca_usage
        return 0
    fi
   
    printf "├─ Examining: ${CYAN}%s${RESET}\n" "$cmd"
   
    # -------------------------------------------------------------------------
    # handle edge cases
    # -------------------------------------------------------------------------    
    if [[ "$cmd" == "}" || "$cmd" == "[[" || "$cmd" == "]]" || "$cmd" == "]" ]]; then 
        declare -A __CA_KEYWORD_DESC=(
        ["}"]="Ends a command block."
        ["[["]="Begins a conditional test expression."
        ["]]"]="Ends a conditional test expression."
        ["]"]="Ends a conditional test expression."
        )
    
        if [[ -n "${__CA_KEYWORD_DESC[$cmd]}" ]]; then

            printf "    ↳ ${CYAN}%s${RESET} is a BASH Keyword  \n" "$cmd"
            printf "    ↳ ${CYAN}%s${RESET} has no help file\n" "$cmd"
            printf "    ↳ Definition:\n\n"
            printf "          ${CYAN}%s${RESET} -- %s\n\n" "$cmd" "${__CA_KEYWORD_DESC[$cmd]}"
        fi
        return 0
    fi
    if [[ $cmd == "(" ]]; then
        printf "    ↳ ${CYAN}%s${RESET} is a BASH Keyword  \n" "$cmd"
        printf "    ↳ ${CYAN}%s${RESET} has no help file\n" "$cmd"
        printf "    ↳ Definition:\n\n" 
        printf "          ${CYAN}%s${RESET} -- Begins a subshell. Commands inside run in a separate process.\n"
        return 0
    fi
    # -------------------------------------------------------------------------
    # Detect command type
    # -------------------------------------------------------------------------
    ctype=$(type -t -- "$cmd" 2>/dev/null)
    
    if [[ -z "$ctype" ]]; then
        printf "├─ ${RED}Unknown or invalid command: ${CYAN}%s${RESET}\n" "$cmd"
        printf "    ↳ Check your spelling and try again\n\n"  
        return 1
    fi
    
    # Dispatch by type
    case "$ctype" in
        alias) _ca_show_alias "$cmd" "$ctype" ;;
        function) _ca_show_function "$cmd" "$ctype" ;;
        builtin) _ca_show_builtin "$cmd" "$ctype" "$cmd";;   
        keyword) _ca_Keywords "$cmd" "$ctype" ;;
        file) _ca_show_external "$cmd" "$ctype" ;;
    esac
}

#------------------------------------------------------------------------
# Function: _ca_show_external
# Process external commands
#------------------------------------------------------------------------
_ca_show_external() {  
    local cmd_real formatted_type file_info perlfound base caps first_line interp
    local size_bytes perms octal owner_grp owner_perm group_perm other_perm risk_color
    local crtime ctime mtime atime
    local kib=1024
    local mib=$((1024 * 1024))
    local gib=$((1024 * 1024 * 1024))
    local tib=$((1024 * 1024 * 1024 * 1024))
    local requires_root=0
    local root_reason=""                    
    local deps=""
    local unmet_found=0            
    local sid=""

    cmd_path=$(command -v "$cmd")    
    cmd_real=$(readlink -f "$cmd_path" 2>/dev/null || echo "$cmd_path")
    file_info=$(file -b "$cmd_real")
    formatted_type=$(printf "%s" "$file_info" | sed -E \
        $'s/, interpreter/\\\ninterpreter/g; 
          s/, version/\\\nversion/g; 
          s/, dynamically/\\\ndynamically/g; 
          s/, BuildID/\\\nBuildID/g; 
          s/, for /\\\nfor /g')
              
    perlfound=0
    if command -v perl &>/dev/null; then
        perlfound=1
    fi      

    printf "    ↳ ${CYAN}%s${RESET} is an external command\n" "$cmd"
    printf "    ↳ Path: ${CYAN}%s${RESET}\n" "$cmd_path"

    # Detect symbolic link
    if [[ "$cmd_real" != "$cmd_path" ]]; then
        printf "    ↳ ${YELLOW}Symbolic link ${RESET}to: ${YELLOW}%s${RESET}\n" "$cmd_real"
        cmd_path="$cmd_real"
        printf "├─ Now Examining: ${BPURP}%s${RESET}\n" "$cmd_real"
    fi
    
    size_bytes=$(stat -c %s "$cmd_path")       
    base=$(basename "$cmd_real")
    _ca_show_path_alternates "$base" "$cmd_real"
        
    printf "    ↳ File Size: "  

    if   (( size_bytes < kib )); then printf "${CYAN}%d B${RESET}\n" "$size_bytes"
    elif (( size_bytes < mib )); then printf "${CYAN}%.1f KB${RESET}\n" "$(echo "$size_bytes / 1024" | bc -l)"
    elif (( size_bytes < gib )); then printf "${CYAN}%.1f MB${RESET}\n" "$(echo "$size_bytes / 1048576" | bc -l)"
    elif (( size_bytes < tib )); then printf "${CYAN}%.1f GB${RESET}\n" "$(echo "$size_bytes / 1073741824" | bc -l)"
    else                         printf "${CYAN}%.1f TB${RESET}\n" "$(echo "$size_bytes / 1099511627776" | bc -l)"
    fi
 
    # Compute SHA using _ca_show_hash
    sha=$(_ca_show_hash "$cmd" 2>/dev/null)      
    printf "    ↳ SHA256: %s%s%s\n" "${CYAN}" "$sha" "${RESET}"
        
    # 1. setuid root
    if [[ -u "$cmd_path" && $(stat -c '%U' "$cmd_path") == "root" ]]; then
        requires_root=1
        root_reason="setuid root binary"

    # 2. capabilities from getcap
    elif command -v getcap &>/dev/null; then
        caps=$(getcap "$cmd_path" 2>/dev/null)
        if [[ "$caps" =~ (cap_sys_admin|cap_dac_override|cap_net_admin) ]]; then
            requires_root=1
            root_reason="binary grants elevated capabilities (getcap)"
        fi
    fi

    # 3. known admin commands
    if (( !requires_root )); then
        local root_cmds=(
            mount umount reboot shutdown halt ifconfig iptables ip
            systemctl journalctl modprobe insmod rmmod fdisk mkfs losetup
            parted fsck useradd userdel passwd chown chmod service sysctl
            visudo fstrim swapoff swapon update-grub grub-install blkid
            update-initramfs
            )
   
        for rcmd in "${root_cmds[@]}"; do
            if [[ "$cmd" == "$rcmd" ]]; then
                requires_root=1
                root_reason="known administrative command"
                break
            fi
        done
    fi
        
    if (( requires_root )); then
        printf "    ↳ Requires root privileges: ${YELLOW}%s${RESET}\n" "$root_reason"
    fi
        
    # Executable Type
    if grep -qiE 'script|text executable' <<< "$file_info"; then
        printf "    ↳ Executable Type: %sScript / Text executable%s\n" "$CYAN" "$RESET"
        first_line=$(head -n1 "$cmd_path")

        if [[ "$first_line" =~ ^#! ]]; then
            interp="${first_line#\#!}"
            interp="${interp#"${interp%%[![:space:]]*}"}"
        fi

        while IFS= read -r line; do
            printf "    ⎟    ${CYAN}%s${RESET}\n" "$line"
        done <<< "$formatted_type"

        printf "    ↳ Interpreter: ${CYAN}%s${RESET}\n" "$interp"

    elif grep -qi 'ELF' <<< "$file_info"; then
        if grep -qi 'statically linked' <<< "$file_info"; then
            printf "    ↳ Executable Type: ELF binary - Statically linked\n"
        else
            printf "    ↳ Executable Type: ELF binary - Dynamically linked\n"
        fi

        while IFS= read -r line; do
            printf "    ⎟    ${CYAN}%s${RESET}\n" "$line"
        done <<< "$formatted_type"

    else
        printf "    ↳ Executable Type: Unknown\n" 
        while IFS= read -r line; do
            printf "    ⎟    ${CYAN}%s${RESET}\n" "$line"
        done <<< "$formatted_type"
        printf "    ⎟       ${YELLOW}%s${RESET}\n" "$file_info"
    fi

    # Dependencies (ELF only)
    if grep -qi ELF <<< "$file_info"; then
        deps=$(ldd "$cmd_path" 2>/dev/null | sed 's/^[[:space:]]*//')
    fi
        
    if [[ -n "$deps" ]]; then
        printf "    ↳ Dependencies:\n"
        local unmet_found=0
        while IFS= read -r line; do
            if [[ "$line" =~ "not found" ]]; then
                unmet_found=1
                printf "    ⎟    ${RED}%s${RESET}\n" "$line"
            else
                printf "    ⎟    ${CYAN}%s${RESET}\n" "$line"
            fi
        done <<< "$deps"
        (( unmet_found )) && printf "        ↳ %sSome dependencies are missing!%s\n" "$RED" "$RESET"
    fi

    # Package info
    _ca_lookup_package "$cmd_path"
        
    # Permissions
    if [[ -x "$cmd_path" ]]; then
        perms=$(stat -c "%A" "$cmd_path")
        octal=$(stat -c "%a" "$cmd_path")
        owner_grp=$(stat -c "%U:%G" "$cmd_path")

        owner_perm="${perms:1:3}"
        group_perm="${perms:4:3}"
        other_perm="${perms:7:3}"

        # Determine risk level
        if [[ ${owner_perm:2:1} =~ [sS] ]]; then
            risk_color="${YELLOW}"      # SUID → high risk
            sid="[SUID]"
        elif [[ ${group_perm:2:1} =~ [sS] ]]; then
            risk_color="${YELLOW}"   # SGID → medium risk
            sid="[SGID]"
        elif [[ ${other_perm} =~ w ]]; then
            risk_color="${RED}"      # world write → very risky
            sid="[World Writable]"  
        else
            risk_color="${CYAN}"    # normal → safe
        fi

        # Highlight the s or S in yellow
        if [[ ${owner_perm:2:1} =~ [sS] ]]; then
            owner_perm="${owner_perm:0:2}${YELLOW}${owner_perm:2:1}${RESET}"
        fi

        if [[ ${group_perm:2:1} =~ [sS] ]]; then
            group_perm="${group_perm:0:2}${YELLOW}${group_perm:2:1}${RESET}"
        fi

        # Output
        printf "    ↳ Permissions: %s%s%s (octal: %s%s%s)  %s%s%s\n" \
             "$risk_color" "$perms" "$RESET" \
            "$risk_color" "$octal" "$RESET" "$risk_color" "$sid" "$RESET"

        printf "    ⎟    ↳ Owner/Group: ${CYAN}%s${RESET}\n" "$owner_grp"

        printf "    ⎟    ↳ Owner: ${CYAN}%s${RESET}  Group: ${CYAN}%s${RESET} Others: ${CYAN}%s${RESET}\n" "$owner_perm" "$group_perm" "$other_perm"
        fi
               
        crtime=$(stat -c %w -- "$cmd_path"); [[ "$crtime" == "-" ]] && crtime="(not available)"
        ctime=$(stat -c %z -- "$cmd_path")
        mtime=$(stat -c %y -- "$cmd_path")
        atime=$(stat -c %x -- "$cmd_path")
        
        printf "    ↳ Timestamps:\n"
        printf "    ⎟    ↳ File created (crtime): ${CYAN}%s${RESET}\n" "$crtime"
        printf "    ⎟    ↳ Last status change (ctime): ${CYAN}%s${RESET}\n" "$ctime" 
        printf "    ⎟    ↳ Last modified (mtime): ${CYAN}%s${RESET}\n" "$mtime"   
        printf "    ⎟    ↳ Last accessed (atime): ${CYAN}%s${RESET}\n" "$atime"         

        found_location=$(printf "\e]8;;file://%s\a%s\e]8;;\a" "$cmd_path" "$cmd_path")
     
        # Dump script content
        if grep -qiE 'script|text executable' <<< "$file_info"; then
            printf "    ↳ Showing preview of script ${CYAN}%s${RESET}: %s\n" "$found_location"
        if (( perlfound == 0 )); then 
            printf "    ↳ %sOptional dependency 'perl' missing — syntax highlighting reduced%s\n" "$YELLOW" "$RESET"
        fi           
        if [[ -r "$cmd_path" ]]; then
            printf "\n"
            _ca_highlight_script "$cmd_path" " " " "

        fi
        return 0
    else
        printf "    └──────────────────────────────────────────\n\n" 
    fi
    return 0
}

#------------------------------------------------------------------------
# Function: _ca_show_alias
# Process aliases
#------------------------------------------------------------------------
_ca_show_alias() {

    local nullglob_was=0
    local line_number alias_def
    local found_location=""
 
    alias_def=$(alias "$cmd")

    _ca_ensure_sourcedtree

    printf "    ↳  ${CYAN}%s${RESET} is an alias:\n" "$cmd"
    printf "    ↳ Resolves to: ${CYAN}%s${RESET}\n" "$alias_def"    
        
    #-----------------------------------------------------
    # Enable nullglob temporarily 
    if shopt -q nullglob; then
        nullglob_was=1
    else
        shopt -s nullglob
    fi
           
    for file in "${__CA_SOURCED_FILES_LIST[@]}"; do 
         [[ -r "$file" ]] || continue
         if grep -qE "^[[:space:]]*alias[[:space:]]+${cmd}=" "$file"; then
             found_location=$(printf "\e]8;;file://%s\a%s\e]8;;\a" "$file" "$file")
             line_number=$(grep -nE "^[[:space:]]*alias[[:space:]]+$cmd=" "$file" | head -n1 | cut -d: -f1)
             printf "    ↳ Defined in: ${CYAN}%s (line %s)${RESET}\n" "$found_location" "$line_number"
         fi
    done
        
    (( !nullglob_was )) && shopt -u nullglob  # Restore nullglob state if we enabled it
    #-----------------------------------------------------
        
    if [[ -z "$found_location" ]]; then
        printf "    ↳ Declared in: %sinteractive shell (not from a file)%s\n" "$CYAN" "$RESET"
    fi     

    # Compute SHA using _ca_show_hash
    sha=$(_ca_show_hash "$cmd" 2>/dev/null)      
    printf "    ↳ SHA256: %s%s%s\n\n" "${CYAN}" "$sha" "${RESET}"
    return 0 
}

#------------------------------------------------------------------------
# Function: _ca_show_function
# Process functions
#------------------------------------------------------------------------
_ca_show_function() {
    #--------------------------- 
    # Enable extdebug temporarily so declare -F includes file/line info
    local was_extdebug=0
    local func_content
    if shopt -q extdebug; then
        was_extdebug=1
    else
        shopt -s extdebug
    fi
        
    read -r _ line file <<< "$(declare -F "$cmd")"

    (( !was_extdebug )) && shopt -u extdebug  # Restore extdebug state if we enabled it
    #---------------------------- 
        
    printf "├─ ${CYAN}'%q' ${RESET}is a shell function\n" "$cmd"
        
    found_location=$(printf "\e]8;;file://%s\a%s\e]8;;\a" "$file" "$file")
              
    if [[ "$file" == "main" ]]; then
        printf "    ↳ Declared in: %sinteractive shell (not from a file)%s\n" "$CYAN" "$RESET"
    else
        printf "    ↳ Declared in: ${CYAN}%s (line %s)${RESET}\n" "$found_location" "$line"
    fi
        
    # Compute SHA using _ca_show_hash
    sha=$(_ca_show_hash "$cmd" 2>/dev/null)      
    printf "    ↳ SHA256: %s%s%s\n" "${CYAN}" "$sha" "${RESET}"
    printf "    ↳ Showing preview of function: ${CYAN}%s${RESET}\n\n" "$cmd"     
           
    func_content=$(declare -f "$cmd")
    _ca_highlight_script "$func_content" "$file" "$line"
       

    return 0
}

#------------------------------------------------------------------------
# Function: _ca_show_builtin
# Process builtins
#------------------------------------------------------------------------
_ca_show_builtin() {
    printf "    ↳ ${CYAN}%s${RESET} is a shell builtin\n" "$cmd"

    # Enabled/disabled
    local enabled_state="enabled"
    if enable -p 2>/dev/null | grep -qE "^-n ${cmd}\b"; then
        enabled_state="disabled"
    fi
    printf "    ↳ Status: Shell builtin is ${CYAN}%s${RESET}\n" "$enabled_state"

    # Loadable builtins
    local origin="Core BASH builtin"
    while read -r loaded; do
        # format: enable -f PATH NAME
        builtin_name="${loaded##* }"
        if [[ "$builtin_name" == "$cmd" ]]; then
            origin="Loadable builtin ($loaded)"
            break
        fi
    done < <(enable -a | grep '^enable -f ' || true)

    printf "    ↳ Source:  ${CYAN}%s${RESET}\n" "$origin"
 
    # Show help
    printf "    ↳ Showing ${CYAN}'help %s'${RESET}:\n\n" "$cmd"
    help "$cmd" 2>/dev/null | sed "s/^/        /"
    return 0
}

#------------------------------------------------------------------------
# Function: _ca_Keywords
# Handle Keywords and edge cases that fail with type. 
#------------------------------------------------------------------------
_ca_Keywords() {
declare -A __CA_KEYWORD_DESC2=(
    [then]="Part of an if statement - Begins the command block for a true condition." 
    [else]="Part of an if statement - Begins the command block if the condition is false." 
    [elif]="Part of an if statement - Introduces a new condition if the previous one is false." 
    [fi]="Ends an if statement."
    [do]="Begins the body of a loop or conditional block."
    [done]="Ends the body of a loop or conditional block." 
    [in]="Specifies the list to iterate over in a loop." 
    [!]="Negates the exit status of a command or pipeline." 
    [esac]="Ends a case statement."
    ["}"]="Ends a command block."
    ["[["]="Begins a conditional test expression."
    ["]]"]="Ends a conditional test expression."
    ["]"]="Ends a conditional test expression."   
)
   
    if [[ $cmd == "(" ]]; then
        printf "    ↳ ${CYAN}%s${RESET} is a BASH Keyword  \n" "$cmd"
        printf "    ↳ ${CYAN}%s${RESET} has no help file\n" "$cmd"
        printf "    ↳ Definition:\n\n" 
        printf "          ${CYAN}%s${RESET} -- Begins a subshell. Commands inside run in a separate process.\n"
        return 0
    fi
   
        printf "    ↳ ${CYAN}%s${RESET} is a BASH Keyword  \n" "$cmd"
    if help "$cmd" &>/dev/null; then
        printf "    ↳ Showing  ${CYAN}'help %s'${RESET}:\n\n" "$cmd"
        help "$cmd" 2>/dev/null | sed 's/^/    /'
    elif [[ -n "${__CA_KEYWORD_DESC2[$cmd]}" ]]; then
        printf "    ↳ ${CYAN}%s${RESET} has no help file\n" "$cmd"
        printf "    ↳ Definition:\n\n"
        printf "          ${CYAN}%s${RESET} -- %s\n\n" "$cmd" "${__CA_KEYWORD_DESC2[$cmd]}"
    fi
    return 0
}  

#------------------------------------------------------------------------
# Function: _ca_usage
# Purpose : Display usage information and examples for the `h` command analyzer.
#------------------------------------------------------------------------
_ca_usage() {
    cat <<'EOF'

     Usage:  ca [command]  
     Analyze aliases, builtins, keywords, functions, scripts or binaries.
   
    Options:
         -h, --help             Show this help text
             --version          Show version information

       Environment inspection:
         -o, --overridden       List commands that override others
         -a, --alias            List all aliases in the environment
         -f, --function         List all USER functions in the environment
         -F, --functionv        Verbose: list ALL functions in the environment
         -d, --diff             List shell options changed from defaults
         -e, --env              List all environment variables (env / printenv)
         -s, --sourced          List all sourced files in the environment
         -p, --path             List directories in $PATH (highlight writable)

       Security / filesystem:
         -u, --user             List USER-writable commands
         -S, --scan             Scan for SUID/SGID binaries and world-writable directories
         -v, --verify           Verify Binary Integrity (dpkg, rpm, pacman)

       Reports / aggregation:
         -r, --report           Full report (includes -t, ca [command], and -v)

       Extras:
             --fzf              Use fzf for interactive searching
   
    Examples:
           ca                   # Automatically analyzes your most recent command
           ca awk               # Analyzes 'awk'
           ca -v sed            # Verify package integrity
           ca -r which          # Full report
EOF

}

#------------------------------------------------------------------------
# Function: _ca_ver
# Purpose : Display version information.
#------------------------------------------------------------------------
_ca_ver() {

    printf "\n     ca v%s  — Command Analyzer\n" "$__CA_version"
    cat <<'EOF'
    
     MIT License
     
     Copyright (c) 2025 John Blair

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in all
     copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     SOFTWARE.

EOF
}

#------------------------------------------------------------------------
# Function: _ca_setup_colors         Colors (tput → ANSI → none)
# Process external commands
#------------------------------------------------------------------------
_ca_setup_colors() {
    if command -v tput &>/dev/null && [[ $(tput colors 2>/dev/null) -ge 8 ]]; then
        # Preferred: tput colors
        RED=$(tput setaf 1)
        GREEN=$(tput setaf 2)
        CYAN=$(tput setaf 6)
        YELLOW=$(tput setaf 11)
        BPURP=$(tput setaf 13)
        GREY=$(tput setaf 245)     # proper neutral gray
        RESET=$(tput sgr0)
        UNLINE=$(tput smul)
        STOPUNLINE=$(tput rmul)
    else
        # Fallback: ANSI escape sequences
        RED='\033[31m'
        GREEN='\033[32m'
        CYAN='\033[36m'
        YELLOW='\033[93m'
        BPURP='\033[95m'
        GREY='\033[90m'  # safe gray
        RESET='\033[0m'
        UNLINE='\033[4m'
        STOPUNLINE='\033[0m'
    fi
 
    : "${RED:=}"
    : "${GREEN:=}"
    : "${CYAN:=}"
    : "${YELLOW:=}"
    : "${BPURP:=}"
    : "${GREY:=}"
    : "${RESET:=}"
    : "${UNLINE:=}"
    : "${STOPUNLINE:=}"
}    

#------------------------------------------------------------------------
# Function: _ca_enable_extglob
# Process aliases
#------------------------------------------------------------------------
_ca_enable_extglob() {
    if shopt -q extglob; then
        __CA_extglob_was=1
    else
        shopt -s extglob
    fi
}

#------------------------------------------------------------------------
# Function: _ca_reset_extglob
# Process aliases
#------------------------------------------------------------------------
_ca_reset_extglob() {
    (( !__CA_extglob_was )) && shopt -u extglob     # Restore extglob state if we enabled it
}

#------------------------------------------------------------------------
# Function: _ca_fzf_search
# start with fzf
#------------------------------------------------------------------------  
_ca_fzf_search() {

    local fzffound=0 pick
    
    if command -v fzf &>/dev/null; then
        fzffound=1
    fi

    if (( fzffound == 1 )); then 
        pick=$(compgen -A function -A alias -A builtin -A command | sort -u | fzf --prompt="Get help for: ")
        [[ -n "$pick" ]] || return 1
        ca "$pick" 
        return 0
    else
        printf "    ↳ %sfzf is not installed.%s\n\n" "$YELLOW" "$RESET"
        _ca_usage
        return 0
    fi  
}

#------------------------------------------------------------------------
# Function: _ca_add_admin_paths
# Purpose: Add ~/.local/bin paths safely and temporarily
#------------------------------------------------------------------------
_ca_add_admin_paths() {
    # Save PATH if not already saved 
    if [[ -z "$__CA_OLD_PATH" ]]; then
        __CA_OLD_PATH="$PATH"
    fi

    local admin_dirs=(
        "$HOME/bin"
        "$HOME/bin/scripts"
        "$HOME/.local/bin"
        "$HOME/.cargo/bin"
        "$HOME/.npm-global/bin"
        "$HOME/.local/share/bash-completion/bin"
        "$CONDA_PREFIX/bin"
        "/flatpak/bin"
        "/snap/bin"
        "/usr/local/bin"
        "/usr/local/sbin"
        "/usr/local/games"
        "/usr/bin"
        "/usr/sbin"
        "/usr/games"
        "/bin"
        "/sbin"
        "/opt/bin"
        "/opt/sbin"
    )
        
    for dir in "${admin_dirs[@]}"; do
        [[ -d "$dir" && ":$PATH:" != *":$dir:"* ]] && PATH="$PATH:$dir"
    done
}

#------------------------------------------------------------------------
# Function: _ca_restore_path
# Automatically restore PATH when leaving scope
#------------------------------------------------------------------------
_ca_restore_path() {
    if [[ -n "$__CA_OLD_PATH" ]]; then
        PATH="$__CA_OLD_PATH"
        unset __CA_OLD_PATH
    fi
}

#------------------------------------------------------------------------
# Function: _ca_completion
# Purpose : Enable tab completion for entering commands 
#------------------------------------------------------------------------
_ca_completion() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local commands
    
    trap '_ca_restore_path' RETURN
    _ca_add_admin_paths
    
    # Collect possible completions: aliases, functions, builtins, and executables in PATH
    mapfile -t commands < <(compgen -A function -A alias -A builtin -A command -- "$cur")
    # Provide them to bash-completion
    COMPREPLY=("${commands[@]}")
}

#------------------------------------------------------------------------
# Function: _ca_sourcedtree
# Purpose: Recursively scan .bashrc for ALL files that are sourced. including conditionals.
#------------------------------------------------------------------------
_ca_sourcedtree() {
    local file files depth max_depth
    depth=0
    max_depth="${MAX_DEPTH:-5}"
    files=("$BASH_ENV")

    # Temporarily enable nullglob
    local nullglob_was=0
    if ! shopt -q nullglob; then
        shopt -s nullglob
        nullglob_was=1
    fi

    if shopt -q login_shell; then
        [[ -d /etc/profile.d ]] && files+=( /etc/profile.d/*.sh )
        [[ -f /etc/profile && -r /etc/profile ]] && files+=( /etc/profile )
        if [[ -f ~/.bash_profile && -r ~/.bash_profile ]]; then 
            files+=( ~/.bash_profile )
        elif [[ -f ~/.bash_login && -r ~/.bash_login ]]; then 
            files+=( ~/.bash_login )
        elif [[ -f ~/.profile && -r ~/.profile ]]; then 
            files+=( ~/.profile )
        fi
    else
        # Non-login interactive shell
        [[ -d /etc/bash.bashrc.d ]] && files+=( /etc/bash.bashrc.d/*.sh )
        [[ -f ~/.bashrc && -r ~/.bashrc ]] && files+=( ~/.bashrc )
        [[ -f /etc/bash.bashrc && -r /etc/bash.bashrc ]] && files+=( /etc/bash.bashrc )
        [[ -f /etc/bashrc && -r /etc/bashrc ]] && files+=( /etc/bashrc )
        if [[ -n "$__CA_RHEL_like" ]]; then
            # This system is Fedora/RHEL-like
            [[ -d /etc/profile.d ]] && files+=( /etc/profile.d/*.sh )
        fi  
    fi 
  
        # Restore nullglob if we changed it
    (( nullglob_was == 1 )) && shopt -u nullglob
              
    for file in "${files[@]}"; do
        _ca_sourcedtree_single "$file" "$depth" "$max_depth"
    done
}

# ----------------------------------------------------------------------
# Function: _ca_sourcedtree_single
# Purpose: _ca_sourcedtree helper, internal recursive function
# ----------------------------------------------------------------------
_ca_sourcedtree_single() {
    local file="$1"
    local depth="${2:-0}"
    (( depth > CA_MAX_DEPTH )) && return

# Expand path
local expanded
expanded=$(_ca_expand_path "$file")
expanded="${expanded%%$'\n'}"   # strip newlines

# Skip empty, duplicates, or unreadable files
[[ -z "$expanded" ]] && return
[[ -n ${__CA_SOURCED_FILES_MAP["$expanded"]} ]] && return
[[ ! -f "$expanded" || ! -r "$expanded" ]] && return

__CA_SOURCED_FILES_MAP["$expanded"]=1
__CA_SOURCED_FILES_LIST+=("$expanded")

    local line f left right

    while IFS= read -r line; do
        # Skip comments and empty lines
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

        #   Standard source/dot
        if [[ $line =~ ^[[:space:]]*(source|\.)[[:space:]]+(.+) ]]; then
            for f in ${BASH_REMATCH[2]}; do
                f=$(_ca_expand_path "$f")
                [[ -f "$f" ]] && _ca_sourcedtree_single "$f" $((depth + 1)) "$CA_MAX_DEPTH"
            done
            continue
        fi

        #  Conditional: [[ -f FILE ]] && source FILE
        if [[ $line == *"&&"* ]]; then
            left=${line%%&&*}
            right=${line#*&&}
            # Remove leading/trailing spaces
            left=${left##*( )}
            left=${left%%*( )}
            right=${right##*( )}
            right=${right%%*( )}

            # Check if left is [[ -f FILE ]] and right is source FILE
            if [[ $left =~ \[\[[[:space:]]*-f[[:space:]]+([^]]+)\]\] ]] && [[ $right =~ ^source[[:space:]]+(.+) ]]; then
                f=$(_ca_expand_path "${BASH_REMATCH[1]}")
                [[ -f "$f" ]] && _ca_sourcedtree_single "$f" $((depth + 1)) "$CA_MAX_DEPTH"
            fi
            continue
        fi

        #   For loops: for VAR in FILES; do source $VAR; done
        if [[ $line =~ ^[[:space:]]*for[[:space:]]+[a-zA-Z_][a-zA-Z0-9_]*[[:space:]]+in[[:space:]]+(.+) ]]; then
            for f in ${BASH_REMATCH[1]}; do
                f=$(_ca_expand_path "$f")
                [[ -f "$f" ]] && _ca_sourcedtree_single "$f" $((depth + 1)) "$CA_MAX_DEPTH"
            done
            continue
        fi

#  Array sourcing: source "${ARRAY[@]}"  (safe mode, no eval)
if [[ $line =~ source[[:space:]]+\"\$\{([a-zA-Z_][a-zA-Z0-9_]*)\[@\]\}\" ]]
then
    local arr_name="${BASH_REMATCH[1]}"
    local decl

    # Extract array declaration safely
    decl=$(declare -p "$arr_name" 2>/dev/null) || return

    # Only allow indexed or associative arrays
    [[ $decl =~ ^declare\ -[aA] ]] || return

    # Extract elements (still text, not executed)
    local elems
    mapfile -t elems < <(
        sed -n 's/^declare \-[aA][^=]*=(//p' <<<"$decl" |
        tr -d '()' |
        tr ' ' '\n'
    )

    for f in "${elems[@]}"; do
        # Reject anything remotely executable
        [[ $f =~ [\$\`\;\&\|] ]] && continue

        f=$(_ca_expand_path "$f")
        [[ -f "$f" ]] && _ca_sourcedtree_single "$f" $((depth + 1)) "$CA_MAX_DEPTH"
    done
fi

    done < "$expanded"
}

# ----------------------------------------------------------------------
# Function: _ca_expand_path
# Purpose: _ca_sourcedtree helper, 
# ----------------------------------------------------------------------
_ca_expand_path() {
    local p="$1"

    # Strip quotes, semicolons, leading/trailing spaces
    p="${p//\"/}"
    p="${p//\'/}"
    p="${p//;/}"
    p="${p##*( )}"
    p="${p%%*( )}"

    # Tilde expansion
    [[ "$p" == "~"* ]] && p="${p/#\~/$HOME}"

    # Replace known environment variables
    [[ -n "$HOME" ]] && p="${p//\$HOME/$HOME}"
    [[ -n "$BASH_ENV" ]] && p="${p//\$BASH_ENV/$BASH_ENV}"

    # Convert to absolute path if possible
    if command -v realpath &>/dev/null && [[ -e "$p" ]]; then
        p=$(realpath "$p" 2>/dev/null || echo "$p")
    fi

    # Remove newlines and trailing spaces
    p="${p//$'\n'/}"
    p="${p%%*( )}"
    printf '%s' "$p"
}

# ----------------------------------------------------------------------
# Function: _ca_ensure_sourcedtree
# Purpose: _ca_sourcedtree helper, track sourced function usage.
# ----------------------------------------------------------------------
_ca_ensure_sourcedtree() {
    (( __CA_SOURCED_SCANNED )) && return
    _ca_sourcedtree
    __CA_SOURCED_SCANNED=1
}

#------------------------------------------------------------------------
# Function: _ca_highlight_script   # _ca_highlight_script "$path-to-script" "<blankspaces>"
# Purpose: Modular syntax highlighting with indentation
#------------------------------------------------------------------------
_ca_highlight_script() {
    local input="$1"
    local INDENT="    "
    local file="$2"
    local line="$3"
   
    # Construct header for literal text or file
    local header=""
    if [[ -n "$file" && -n "$line" ]]; then
        if [[ "$file" == "main" ]]; then
            header="Interactive shell (not from a file)"
        else    
        header="$file (line $line)"
        fi
    elif [[ -f "$input" ]]; then
        header="$input"
    fi
            
    # Read file if it exists
    local code
    if [[ -f "$input" ]]; then
        code=$(<"$input")
    else
        code="$input"
    fi
    
    #----------------------------------------
    # Choose bat or batcat, if available
    local bat_pager=""
    if command -v bat &>/dev/null; then
        bat_pager="bat"
    elif command -v batcat &>/dev/null; then
        bat_pager="batcat"
    fi

    #----------------------------------------
    # If bat is available, use it
    if [[ -n "$bat_pager" ]]; then
        if [[ -f "$input" ]]; then
            "$bat_pager" --color=always --paging=never --line-range :50 --file-name "$input" "$input" \
            | sed "s/^/    /"
        else
            # Input is literal text → use process substitution
            printf "%s\n" "$code" \
            | "$bat_pager" --color=always --language bash --paging=never --line-range :50 --file-name "$header" - \
            | sed "s/^/    /"
        fi
        return
    fi

    perl - "$code" "$INDENT" <<'PERL_CODE'
use strict;
use warnings;

my $content = $ARGV[0];
my $INDENT = $ARGV[1] // "";

# ANSI colors
my %C = (
    comment   => "\e[36m",
    string    => "\e[96m",
    subshell  => "\e[35m",
    decl      => "\e[32m",
    control   => "\e[93m",
    builtin   => "\e[32m",
    command   => "\e[35m",
    variable  => "\e[33m",
    number    => "\e[34m",
    bracket   => "\e[37m",
    reset     => "\e[0m",
);

# Patterns for syntax highlighting
my @patterns = (
    { regex => qr/("(?:[^"\\]|\\.)*")/,       color => 'string' },
    { regex => qr/('(?:[^'\\]|\\.)*')/,       color => 'string' },
    { regex => qr/\$\((?:[^()]+|(?R))*\)/x,   color => 'subshell' },
    { regex => qr/`[^`]*`/,                    color => 'subshell' },
    { regex => qr/\b(local|declare|export|typeset)\b/, color => 'decl' },
    { regex => qr/\b(if|then|else|elif|fi|for|while|do|done|until|select|case|esac|break|continue)\b/, color => 'control' },
    { regex => qr/\b(function|return|exit|trap|shift|read|mapfile|set|unset)\b/, color => 'builtin' },
    { regex => qr/\b(printf|echo|mkdir|find|grep|sed|awk|cut|sort|head|tail|xargs|cat|touch|chmod|chown|curl|wget)\b/, color => 'command' },
    { regex => qr/\$[A-Za-z0-9_@#*!?_-]+/, color => 'variable' },
    { regex => qr/\b[0-9]+(\.[0-9]+)?\b|0x[0-9A-Fa-f]+/, color => 'number' },
    { regex => qr/\[\[|\]\]|\(\(|\)\)|\(|\)|\{|\}/, color => 'bracket' },
    { regex => qr/#.*/, color => 'comment' },
);

sub highlight {
    my ($line, $INDENT) = @_;
    foreach my $p (@patterns) {
        $line =~ s/($p->{regex})/$C{$p->{color}}$1$C{reset}/g;
    }
    return $INDENT . $line;
}

for my $line (split /\n/, $content) {
    print highlight($line, $INDENT), "\n";
}
PERL_CODE
}

#------------------------------------------------------------------------
# Function: _ca_check_dependencies
# Purpose : Check core and optional dependencies, optionally exit on missing core deps
# Usage   : _ca_check_dependencies __CA_needed_deps __CA_optional_deps [EXIT_ON_MISSING] 0or1
#------------------------------------------------------------------------
_ca_check_dependencies() {
    local -n required="$1"
    local -n optional="$2"
    local exit_on_missing="${3:-1}"

    local missing_required=()
    local missing_optional=()

    for cmd in "${required[@]}"; do
        command -v "$cmd" >/dev/null 2>&1 || missing_required+=("$cmd")
    done

    for cmd in "${optional[@]}"; do
        command -v "$cmd" >/dev/null 2>&1 || missing_optional+=("$cmd")
    done

    if (( ${#missing_required[@]} )); then
        printf "%b\n" "${RED}Warning: Missing REQUIRED tools: ${missing_required[*]}${RESET}"
        if (( exit_on_missing )); then
            printf "%b\n" "${RED}Cannot continue analysis without core dependencies.${RESET}"
            if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
                exit 1
            else
                return 1
            fi
        fi
    fi

    return 0
}

#------------------------------------------------------------------------
# Function: _ca_conflicts                     
# Purpose : list all commands that conflict with other command names
#------------------------------------------------------------------------
_ca_conflicts() {
    printf "├─ Examining Conflicting Command Names:\n" 
    _ca_keyword_conflicts
    _ca_alias_conflicts
    _ca_function_conflicts
    _ca_builtin_conflicts
}

#------------------------------------------------------------------------
# Function: _ca_keyword_conflicts
# Purpose : list all shell keywords that conflict with other command names
#------------------------------------------------------------------------
_ca_keyword_conflicts() {
    local kw kinds

    # List shell keywords
    while IFS= read -r kw; do
        # Get all resolutions except the keyword itself
        mapfile -t kinds < <(type -at "$kw" | grep -v '^keyword$')

        if ((${#kinds[@]} > 0)); then
            printf "  ↳ Keyword: ${CYAN}%-11s${RESET} Conflicts with one or more commands.\n" "$kw"
        fi
    done < <(compgen -k)
    printf "  ⎟ \n"
}

#------------------------------------------------------------------------
# Function: _ca_alias_conflicts
# Purpose : list all aliases that conflict with other command names
#------------------------------------------------------------------------
_ca_alias_conflicts() {
    local acmd kinds 

    while IFS= read -r acmd; do
        # Get all resolutions except the alias itself
        mapfile -t kinds < <(type -at "$acmd" | grep -v '^alias$')

        if ((${#kinds[@]} > 0)); then
            printf "  ↳ Alias: ${CYAN}%-13s${RESET} Conflicts with one or more commands.\n" "$acmd"
        fi
    done < <(alias | sed -E 's/^alias ([^=]+)=.*/\1/')
    printf "  ⎟ \n"
}

#------------------------------------------------------------------------
# Function: _ca_function_conflicts
# Purpose : list all shell functions that conflict with other command names
#------------------------------------------------------------------------
_ca_function_conflicts() {
    local fname kinds

    # List function names only
    while IFS= read -r fname; do
        # Get all resolutions except the function itself
        mapfile -t kinds < <(type -at "$fname" | grep -v '^function$')

        if ((${#kinds[@]} > 0)); then
            printf "  ↳ Function: ${CYAN}%-10s${RESET} Conflicts with one or more commands.\n" "$fname"
        fi
    done < <(declare -F | awk '{print $3}')
    printf "  ⎟ \n"
}

#------------------------------------------------------------------------
# Function: _ca_builtin_conflicts
# Purpose : list all builtins that conflict with other command names
#------------------------------------------------------------------------
_ca_builtin_conflicts() {
    local bcmd kinds

    # List builtin names
    while IFS= read -r bcmd; do
        # Get all resolutions except the builtin itself
        mapfile -t kinds < <(type -at "$bcmd" | grep -v '^builtin$')

        if ((${#kinds[@]} > 0)); then
            printf "  ↳ Builtin: ${CYAN}%-11s${RESET} Conflicts with one or more commands.\n" "$bcmd"
        fi
    done < <(compgen -b)
}

#------------------------------------------------------------------------
# Function: _ca_display_files_scan
# Purpose : scan for SUID / SGID binaries and World-Writable directories 
#------------------------------------------------------------------------
_ca_display_files_scan() {
    printf "├─ Examining SUID/SGID Commands and World-writable Directories:\n"
    _ca_suid_scan
    printf "\n"
    _ca_sgid_scan
    printf "\n"
    _ca_find_world_writable_dirs
}

#------------------------------------------------------------------------
# Function: _ca_sgid_scan
# Purpose : Scan for SGID binaries
#------------------------------------------------------------------------
_ca_sgid_scan() {
    printf "├─ SGID binaries:\n"
    printf "    ↳ Scanning filesystem… this may take a few seconds.\n"
    while IFS= read -r hitg; do
        printf "    ↳ ${CYAN}%s${RESET}\n" "$hitg"
    done < <(find / -perm -2000 -type f -exec ls -l {} + 2>/dev/null)
}

#------------------------------------------------------------------------
# Function: _ca_suid_scan
# Purpose : Scan for SUID binaries
#------------------------------------------------------------------------
_ca_suid_scan() {
    printf "├─ SUID binaries:\n"
    printf "    ↳ Scanning filesystem… this may take a few seconds.\n"
    while IFS= read -r hit; do
        printf "    ↳ ${CYAN}%s${RESET}\n" "$hit"
    done < <(find / -perm -4000 -type f -exec ls -l {} + 2>/dev/null)
}

#------------------------------------------------------------------------
# Function: _ca_find_world_writable_dirs
# Purpose : Scan for world_writable_dirs
#------------------------------------------------------------------------
_ca_find_world_writable_dirs() {

    printf "├─ World-Writable directories:\n"
    printf "    ↳ Scanning filesystem… this may take a few seconds.\n"
    # Find world-writable directories
    mapfile -t dirs < <(find / -type d -perm -0002 2>/dev/null)

    for dir in "${dirs[@]}"; do
        [ -d "$dir" ] || continue

        perms=$(stat -c "%A" "$dir")
        owner_g=$(stat -c "%U:%G" "$dir")
        note=""

        # Check sticky bit (position 9)
        sticky="${perms:9:1}"

        if [ "$sticky" = "t" ] || [ "$sticky" = "T" ]; then
            note="${CYAN}WORLD-WRITABLE + STICKY${RESET}"
            printf "    ↳ ${CYAN}%-40s %-10s %-20s %-25s${RESET}\n" "$dir" "$perms" "$owner_g" "$note"
        else
            note="${RED}WORLD-WRITABLE!${RESET}"
            printf "    ↳ ${RED}%-40s %-10s %-20s %-25s${RESET}\n" "$dir" "$perms" "$owner_g" "$note"
        fi
    done
}

#------------------------------------------------------------------------
# Function: _ca_writable_dir_in_path
# Purpose : Detect writable directories in $PATH
#------------------------------------------------------------------------
_ca_writable_dir_in_path() {
_ca_restore_path
    printf "├─ Examining PATH directory Order and Permissions:\n"
    printf "    ↳ %s%-40s %-15s %-20s %-10s%s\n" "$UNLINE" "Directory" "Perms" "Owner:Group" "Note" "$STOPUNLINE"
    
    IFS=: read -ra dirs <<< "$PATH"
    for dir in "${dirs[@]}"; do
    if [ ! -d "$dir" ]; then
        # Directory does not exist
        perms="N/A"
        owner_g="N/A"
        note="${BPURP}MISSING${RESET}"
        printf "    ↳ ${BPURP}%-40s %-15s %-20s ${RESET}%-10s\n" "$dir" "$perms" "$owner_g" "$note"
        continue
    fi

    # Directory exists
    target=$(readlink -f "$dir" 2>/dev/null || echo "$dir")
    perms=$(stat -c "%A" "$target" 2>/dev/null || echo "N/A")
    owner_g=$(stat -c "%U:%G" "$target" 2>/dev/null || echo "N/A")
    note=""

    if [[ "${perms:8:1}" == "w" ]]; then
        note="${RED}WORLD-WRITABLE${RESET}"
        printf "    ↳ ${RED}%-40s %-15s %-20s ${RESET}%-10s\n" "$dir" "$perms" "$owner_g" "$note"
    elif [ -w "$dir" ]; then
        note="Writable"
        printf "    ↳ ${CYAN}%-40s %-15s %-20s %-10s${RESET}\n" "$dir" "$perms" "$owner_g" "$note"
    else
        printf "    ↳ %-40s %-15s %-20s %-10s\n" "$dir" "$perms" "$owner_g" "$note"
    fi
    done
}


#------------------------------------------------------------------------
# Function: _ca_sourced_files
# Purpose: display ALL files that are sourced.
#------------------------------------------------------------------------
_ca_sourced_files() {
 #   _ca_sourcedtree
    printf "├─ Examining Sourced Files:\n"
    printf "    ↳ Scanning filesystem… this may take a few seconds.\n"

    local phase
    local -a roots ordered
    local f



    # Temporarily enable nullglob
    local nullglob_was=0
    if ! shopt -q nullglob; then
        shopt -s nullglob
        nullglob_was=1
    fi

    #-------------------------------------------------------
    # Phase 1: Non-interactive
    if [[ -n "$BASH_ENV" && -f "$BASH_ENV" ]]; then
        roots+=( "$BASH_ENV" )
        phase="non-interactive"
    fi

    #-------------------------------------------------------
    # Phase 2: Login shell
    if shopt -q login_shell; then
        phase="login"

        [[ -f /etc/profile ]] && roots+=( /etc/profile )
        [[ -d /etc/profile.d ]] && roots+=( /etc/profile.d/*.sh )
    
        if [[ -f ~/.bash_profile ]]; then
            roots+=( ~/.bash_profile )
        elif [[ -f ~/.bash_login ]]; then
            roots+=( ~/.bash_login )
        elif [[ -f ~/.profile ]]; then
            roots+=( ~/.profile )
        fi

    #-------------------------------------------------------
    # Phase 3: Interactive non-login
    elif [[ $- == *i* ]]; then
        phase="interactive non-login"

        [[ -f /etc/bash.bashrc ]] && roots+=( /etc/bash.bashrc )
        [[ -f /etc/bashrc ]] && roots+=( /etc/bashrc )
        [[ -f ~/.bashrc ]] && roots+=( ~/.bashrc )
    fi

    if (( __CA_RHEL_like == 1 )); then
        # This system is Fedora/RHEL-like
        [[ -d /etc/profile.d ]] && roots+=( /etc/profile.d/*.sh )
    fi 

    # Restore nullglob if we changed it
    (( nullglob_was == 1 )) && shopt -u nullglob

    #-------------------------------------------------------
    # Static discovery pass
    for f in "${roots[@]}"; do
        _ca_sourcedtree_single "$f" 0 "$CA_MAX_DEPTH"
    done

    #-------------------------------------------------------
    # Emit ordered walk
    # Root files first, then discovered children
    for f in "${roots[@]}"; do
        f=$(_ca_expand_path "$f")
        [[ -f "$f" ]] && ordered+=( "$f" )
    done

    for f in "${__CA_SOURCED_FILES_LIST[@]}"; do
        [[ " ${ordered[*]} " != *" $f "* ]] && ordered+=( "$f" )
    done

    #-------------------------------------------------------
    # Output
    
    printf "    ↳ %sDiscovered the following files%s:\n" "$UNLINE" "$STOPUNLINE"

    local i=0
    for f in "${ordered[@]}"; do
      #  printf "    ↳ ${CYAN}%s${RESET}\n" "$file" 
        # Build clickable line
        local clickable_text
        clickable_text=$(printf "${CYAN}%s${RESET}" "$f")
        # Print clickable link
        printf "    ↳ \e]8;;file://%s\a%s\e]8;;\a\n" "$f" "$clickable_text"
    done
}

#------------------------------------------------------------------------
# Function: _ca_show_path_alternates
# Purpose : Display path shadowing of a command
#------------------------------------------------------------------------
_ca_show_path_alternates() {
    local cmd="$1" cmdpath="$2"
    local shad=()
    local dir

    IFS=':' read -ra PATH_ARR <<< "$PATH"
    for dir in "${PATH_ARR[@]}"; do
        [[ -z "$dir" ]] && dir="."
        local p="$dir/$cmd"

        [[ -f "$p" && -x "$p" ]] || continue
        [[ "$p" == "$cmdpath" ]] && continue

        shad+=("$p")
    done

    (( ${#shad[@]} == 0 )) && return 0

    printf "    ↳ Alternate PATH matches:\n"

    local s
    for s in "${shad[@]}"; do
        printf "    │    ${CYAN}%s${RESET}\n" "$s"
    done
}

#------------------------------------------------------------------------
# Function: _ca_lookup_package  # usage: _ca_lookup_package "$cmd_path" 
# Purpose : Lookup package info for a given command path
#------------------------------------------------------------------------
_ca_lookup_package() {
    local cmd_path="$1"

    local pkg_mgr pkg_name pkg_lines=()

    pkg_mgr=$(_ca_detect_pkg_manager)
    [[ -z "$pkg_mgr" ]] && return 1  # no package manager detected

    case "$pkg_mgr" in
        dpkg)
            pkg_name=$(dpkg -S "$cmd_path" 2>/dev/null | cut -d: -f1 | head -n1)
            if [[ -n "$pkg_name" ]]; then
                while IFS= read -r line; do pkg_lines+=("$line"); done \
                    < <(dpkg-query -W -f='${Package}\n${Version}\n${Maintainer}\n${Description}\n' "$pkg_name" 2>/dev/null)
            fi
            ;;
        rpm)
            pkg_name=$(rpm -qf "$cmd_path" 2>/dev/null)
            if [[ -n "$pkg_name" && "$pkg_name" != "file $cmd_path is not owned by any package" ]]; then
                while IFS= read -r line; do pkg_lines+=("$line"); done \
                    < <(rpm -qi "$pkg_name" | awk '
                    NR==1 { pkg=$3 }
                    NR==2 { ver=$3 }
                    /^Vendor/ {
                    vendor = $3 " " $4      # space between $3 and $4
                    }
                    /^Summary/ {
                    # print from field 3 to end
                    desc = substr($0, index($0, $3))
                    }
                    END {
                    print pkg
                    print ver
                    print vendor
                    print desc
                    }
                ')
            fi
            ;;   
        pacman)
            pkg_name=$(pacman -Qo "$cmd_path" 2>/dev/null | awk '{print $5}')
            if [[ -n "$pkg_name" ]]; then
                while IFS= read -r line; do pkg_lines+=("$line"); done \
                < <(pacman -Qi "$pkg_name" | awk -F': *' '
                    /^Name/        { name=$2 }
                    /^Version/     { ver=$2 }
                    /^Packager/    { maint=$2 }
                    /^Description/ { desc=$2 }
                    END {
                        print name
                        print ver
                        print maint
                        print desc
                    }
               ')
           fi
           ;;
    esac

    # Print package info if available   ----works for apt and rpm
    if [[ -n "${pkg_lines[0]}" ]]; then
        printf "    ↳ Package Info:\n"
        printf "    ⎟    Package: ${CYAN}%s${RESET}\n" "${pkg_lines[0]}"
        printf "    ⎟    Version: ${CYAN}%s${RESET}\n" "${pkg_lines[1]}"
        printf "    ⎟    Maintainer: ${CYAN}%s${RESET}\n" "${pkg_lines[2]}"
        printf "    ⎟    Description: ${CYAN}%s${RESET}\n" "${pkg_lines[3]}"
    fi
}

#------------------------------------------------------------------------
# Function: _ca_detect_pkg_manager  
# Purpose : detect package manager
#------------------------------------------------------------------------
_ca_detect_pkg_manager() {
    if command -v dpkg &>/dev/null; then
        echo "dpkg"
    elif command -v rpm &>/dev/null; then
        echo "rpm"
    elif command -v pacman &>/dev/null; then
        echo "pacman"
    else
        echo ""
    fi
}

#------------------------------------------------------------------------
# Function: _ca_verify_binary  # usage: _ca_verify_binary "$cmd_path" 
# Purpose : verify package for a given command
#------------------------------------------------------------------------
_ca_verify_binary() {
    local cmd="$1"
    local ctype pkg status cmd_path cmd_real verify pkg_mgr bash_hit
    sha="Unknown"
    status="${GREEN}Command is CLEAN${RESET}"
    bash_hit=0
    
    # guard against trash commands
    ctype=$(type -t -- "$cmd" 2>/dev/null)
    if [[ -z "$ctype" ]]; then
        printf "├─ ${RED}Unknown or invalid command:${CYAN} %s${RESET}\n" "$cmd"
        printf "    ↳ Check your spelling and try again\n\n" 
        return 1
    fi

    # Compute SHA using _ca_show_hash
    sha=$(_ca_show_hash "$cmd" 2>/dev/null)

    case "$ctype" in
        alias)
            pkg="${YELLOW}Not From a Package${RESET}"
            status="${YELLOW}BASH Alias (not verifiable)${RESET}"
            printf "├─ Verifying Binary Integrity:\n" 
            printf "    ├─ Alias: ${CYAN}%s${RESET}\n" "$cmd"
            printf "    ⎟\n"
            printf "    ├─ Package: ${CYAN}%s${RESET}\n" "${pkg}"
            printf "    ├─ SHA256: ${CYAN}%s${RESET}\n" "$sha"    
            printf "    └─ Status: %s\n" "$status"
            return 0
            ;;
        function)
            pkg="${YELLOW}Not From a Package${RESET}"
            status="${YELLOW}BASH Function (not verifiable)${RESET}"
            printf "├─ Verifying Binary Integrity:\n" 
            printf "    ├─ Function: ${CYAN}%s${RESET}\n" "$cmd"
            printf "    ⎟\n"
            printf "    ├─ Package: ${CYAN}%s${RESET}\n" "${pkg}"
            printf "    ├─ SHA256: ${CYAN}%s${RESET}\n" "$sha"    
            printf "    └─ Status: %s\n" "$status"
            return 0           
            ;;
        builtin|keyword)
            bash_hit=1
            ctype="file"
            ;;
    esac    
    
    if [[ "$ctype" == "file" ]]; then      
        cmd_path=$(command -v "$cmd") 
        cmd_real=$(readlink -f "$cmd_path" 2>/dev/null || echo "$cmd_path")
   
        # Compute SHA using _ca_show_hash
        sha=$(_ca_show_hash "$cmd_real" 2>/dev/null)
           
        pkg_mgr=$(_ca_detect_pkg_manager)
        [[ -z "$pkg_mgr" ]] && return 1  # no package manager detected

        if (( bash_hit == 1 )); then 
             cmd_real=/usr/bin/bash
             sha=$(_ca_show_hash "$cmd_real" 2>/dev/null)
        fi
                 
        case "$pkg_mgr" in
            dpkg)
                pkg=$(dpkg -S "$cmd_real" 2>/dev/null | cut -d: -f1)
                if [[ -n "$pkg" ]]; then
                    verify=$(dpkg -V "$pkg" | grep -F "$cmd_real")
                fi
                ;;
            rpm)
                if pkg=$(rpm -qf "$cmd_real" 2>/dev/null); then
                    verify=$(rpm -V "$pkg" | grep -F "$cmd_real")
                fi
                ;;   
            pacman)
                pkg=$(pacman -Qo "$cmd_real" 2>/dev/null | cut -d' ' -f5)
                if [[ -n "$pkg" ]]; then
                    verify=$(pacman -Qk "$pkg" 2>/dev/null | grep -F "$cmd_real")
                fi
                ;;
        esac

        if [[ -n "$verify" ]]; then
            status="${RED}COMMAND HAS BEEN MODIFIED${RESET}"
        elif (( bash_hit == 1 )); then
            status="${GREEN}CLEAN (shell binary verified)${RESET}"           
        elif [[ -z "$pkg" ]]; then
            status="${YELLOW}USER INSTALLED (not verifiable)${RESET}"   
        fi
           
   
    if (( bash_hit == 1 )); then 
        printf "├─ Verifying Binary Integrity:\n" 
        printf "    ├─ Builtin/Keyword: ${CYAN}%s${RESET}\n" "$cmd"    
        printf "    ⎟\n"
        printf "    ├─ Builtins and Keywords are provided by BASH itself\n" 
    elif [[ "$(basename "$cmd_real")" != "$cmd" ]]; then
        printf "├─ Verifying Binary Integrity:\n" 
        printf "    ├─ Command: ${CYAN}%s${RESET}\n" "$cmd"    
        printf "    ├─ Resolves to: ${CYAN}%s${RESET} → ${BPURP}[ %s ]${RESET}\n" "$cmd" "$(basename "$cmd_real")"
    else
        printf "├─ Verifying Binary Integrity:\n" 
        printf "    ├─ Command: ${CYAN}%s${RESET}\n" "$cmd"   
    fi
    
        printf "    ⎟\n"
            
        if [[ "$(basename "$cmd_real")" != "$cmd" ]]; then
            printf "    ├─ Package: ${BPURP}%s${RESET}\n" "${pkg:-none}"
        elif [[ -n "$pkg" ]]; then  # pkg present
            printf "    ├─ Package: ${CYAN}%s${RESET}\n" "$pkg"
        else                        # pkg empty
            printf "    ├─ Package: %sNot From a Package%s\n" "$YELLOW" "$RESET"
        fi
        printf "    ├─ Path: ${CYAN}%s${RESET}\n" "$cmd_real"
        printf "    ├─ SHA256: ${CYAN}%s${RESET}\n" "$sha"                
        printf "    └─ Status: %s\n" "$status"   
    fi
}

#------------------------------------------------------------------------
# Function: _ca_show_hash  # usage: _ca_show_hash "$cmd_path"
# Purpose : calc hashes
#------------------------------------------------------------------------
_ca_show_hash() {
    local cmd="$1"
    local ctype hash=""
    ctype=$(type -t -- "$cmd" 2>/dev/null)
    
    case "$ctype" in
        alias) 
            hash=$(alias "$cmd" 2>/dev/null | awk -F"=" '{print $2}' | sha256sum | awk '{print $1}')
            ;;
        function) 
            hash=$(declare -f "$cmd" | sha256sum | awk '{print $1}') 
            ;;
        file) 
            local path
            path=$(command -v "$cmd")
            if [[ -x "$path" ]]; then
                hash=$(sha256sum "$path" | awk '{print $1}')
            fi
            ;;
    esac
    
    printf "%s" "$hash"
}

#-----------------------------------------------------------
# Function: _ca_list_user_bin
# Purpose : Identify user writable commands/scripts/binaries
#-----------------------------------------------------------
_ca_list_user_bin() {
    local found=0
    local IFS=:
    local -A seen
    local fn clickable_text
    
    _ca_restore_path   
    
    printf "├─ Examining User-Writable Commands:\n"
        
    for dir in $PATH; do
        [[ -d $dir ]] || continue

        # Exclude system dirs explicitly
        case "$dir" in
            /bin|/usr/bin|/usr/sbin|/sbin) continue ;;
        esac

        shopt -s nullglob
        for f in "$dir"/*; do
            [[ -f $f && -x $f && -w $f ]] || continue
            [[ -n ${seen[$f]} ]] && continue
            seen[$f]=1
            fn=$(basename "$f")
            clickable_text=$(printf "${CYAN}(%s)${RESET}" "$f")
            printf "     %-25s  -- Defined in: \e]8;;file://%s\a%s\e]8;;\a\n" "$fn" "$f" "$clickable_text"         
            found=1
        done
        shopt -u nullglob
    done

    (( found )) || printf "    No user-writable executables found.\n\n"
}

# ----------------------------------------------------------------------
# Function: _ca_function
# Builds a clickable list of shell functions with file links
# ----------------------------------------------------------------------
_ca_function() {
    local verbose=${verbose:-0}
    local fn
    if [[ "$verbose" == 1 ]]; then
        printf "├─ Examining ALL Shell Functions: \n"
        # Show all functions including internal
        compgen -A function | while read -r fn; do
            _ca_print_fn "$fn" 
        done
    else
        printf "├─ Examining USER Shell Functions: \n"
        # Filter out internal/system functions
        compgen -A function | grep -Ev '^(__|_|_comp|_python_)' | while read -r fn; do
            _ca_print_fn "$fn" 
        done
    fi
}

#------------------------------------------------------------------------
# Function: _ca_print_fn
# Purpose: _ca_function helper - print a single function line with clickable link
#------------------------------------------------------------------------
_ca_print_fn() {
    local fn="$1"
    local was_extdebug=0 _ line file

    # Enable extdebug to get file/line
    if ! shopt -q extdebug; then
        shopt -s extdebug
        was_extdebug=1
    fi

    read -r _ line file <<< "$(declare -F "$fn")"
    (( was_extdebug )) && shopt -u extdebug

    # Default fallback for interactive or missing file
    [[ -z "$file" ]] && file="?"

    # Build clickable line with function name, file, line
    local clickable_text
    clickable_text=$(printf "${CYAN}(%s : line %s)${RESET}" \
            "$file" "$line")
            
    # Print clickable link
    printf "     %-30s  -- Found in: \e]8;;file://%s\a%s\e]8;;\a\n" "$fn" "$file" "$clickable_text"
}
                
# ----------------------------------------------------------------------
# Function: _ca_aliases
# Builds a clickable list of shell aliases with file links
# ----------------------------------------------------------------------
_ca_aliases() {

    _ca_ensure_sourcedtree
    [[ -z "${__CA_SOURCED_FILES_LIST[*]}" ]] && return

    local nullglob_was=0
    shopt -q nullglob || { shopt -s nullglob; nullglob_was=1; }
    printf "├─ Examining Shell Aliases:\n"
    for alias_name in $(compgen -A alias); do
        local file line_number last_file last_line

        # Escape alias name for regex
        local alias_re
        alias_re=$(printf '%s\n' "$alias_name" | sed 's/[][\\/.*^$+?{}|()]/\\&/g')

        # Walk files in load order; keep LAST match
        for file in "${__CA_SOURCED_FILES_LIST[@]}"; do
            [[ -r $file ]] || continue
            line_number=$(grep -nE "^[[:space:]]*alias[[:space:]]+${alias_re}[[:space:]]*=" "$file" | tail -n1 | cut -d: -f1)
            [[ -n $line_number ]] && { last_file=$file; last_line=$line_number; }
        done

        [[ -z $last_file ]] && continue

        printf "     %-10s  -- Found in: %s\e]8;;file://%s\a%s : line %s\e]8;;\a%s\n" "$alias_name" "$CYAN" "$last_file" "$last_file" "$last_line" "$RESET"
            
    done

    (( nullglob_was )) && shopt -u nullglob
}

#------------------------------------------------------------------------
# Function: _ca_bash_option_diff
# Purpose: shell option diff from default state
#------------------------------------------------------------------------
_ca_bash_option_diff() {
    local tmp_default tmp_current
    
    printf "├─ Examining Shell options (Default vs Current): \n"                        

    tmp_default=$(mktemp)
    tmp_current=$(mktemp)

    # Normalize output from set -o and shopt -p
    _ca_normalize() {
        while IFS= read -r line; do
            if [[ "$line" =~ ^([a-z_-]+)[[:space:]]+(on|off)$ ]]; then
                # set -o output
                echo "set:${BASH_REMATCH[1]}=${BASH_REMATCH[2]}"
            elif [[ "$line" =~ ^shopt[[:space:]]+(-s|-u)[[:space:]]+([a-z_-]+)$ ]]; then
                local state
                [[ "${BASH_REMATCH[1]}" == "-s" ]] && state="on" || state="off"
                echo "shopt:${BASH_REMATCH[2]}=$state"
            fi
        done
    }

    # Capture default shell options
    bash --noprofile --norc -c 'set -o; shopt -p' | _ca_normalize | sort > "$tmp_default"
    # Capture current shell options
    { set -o; shopt -p; } | _ca_normalize | sort > "$tmp_current"

    local changed=0

    # Read defaults and compare with current
    while IFS='=' read -r key default_val; do
        local current_val
        current_val=$(grep -F "$key=" "$tmp_current" | cut -d= -f2)
        # If current_val is empty, assume missing (shouldn't happen)
        current_val=${current_val:-missing}

        if [[ "$default_val" != "$current_val" ]]; then
            changed=1
            local state color
            if [[ "$current_val" == "on" ]]; then
                state="ENABLED"
                color="$GREEN"
            else
                state="DISABLED"
                color="$RED"
            fi
            printf "    %s%-8s%s %-25s (%s → %s)\n" \
                 "$color" "$state" "$RESET" "$key" "$default_val" "$current_val"
        fi
    done < "$tmp_default"

    # Empty case
    if [ $changed -eq 0 ]; then
        printf "    No shell options differ from default.\n"
    fi
    
    rm -f "$tmp_default" "$tmp_current"
}

#-----------------------------------------------------------
# Function: _ca_list_env
# List all exported environment variables, sorted
#-----------------------------------------------------------
_ca_list_env() {
    local cmd
    local width name value wrap line

    _ca_restore_path
    command -v printenv &>/dev/null && cmd="printenv" || cmd="env"

    # Determine terminal width with fallback
    width=${COLUMNS:-$(tput cols 2>/dev/null)}
    width=$((width - 4))
    [[ $width -le 0 ]] && width=76

    printf "├─ Examining Enviroment Variables: \n"                        

    # Read variables
    eval "$cmd" | while IFS='=' read -r name value; do
        # Determine if variable should wrap by colon
        case "$name" in
            PATH|LD_LIBRARY_PATH|XDG_DATA_DIRS|LS_COLORS)
                wrap=true ;;
            *)
                wrap=false ;;
        esac

        # Print variable name
        printf "    ${CYAN}%s${RESET}=" "$name"

        if $wrap; then
            # Split colon-separated values safely
            IFS=':' read -ra parts <<< "$value"
            line=""
            for part in "${parts[@]}"; do
                # Start a new line if it would overflow width
                if [ $(( ${#line} + ${#part} + 1 )) -gt $width ]; then
                    # Print existing line
                    printf "%s\n        " "$line"
                    line="$part"
                else
                    [[ -z $line ]] && line="$part" || line="$line:$part"
                fi
            done
            # Print remaining line
            printf "%s\n" "$line"
        else
            # Fold normal variable values with indentation
            echo "$value" | fold -s -w "$width" | sed '2,$s/^/        /'
        fi
    done
}

#-----------------------------------------------------------
# Function: _ca_walk_bash_startup
# Purpose : Walk Bash startup files in correct semantic order
#-----------------------------------------------------------
_ca_walk_bash_startup() {
    local phase
    local -a roots ordered
    local f

    # Reset global state (important)
    __CA_SOURCED_FILES_MAP=()
    __CA_SOURCED_FILES_LIST=()
    __CA_SOURCED_SCANNED=0

    # Temporarily enable nullglob
    local nullglob_was=0
    if ! shopt -q nullglob; then
        shopt -s nullglob
        nullglob_was=1
    fi

    #-------------------------------------------------------
    # Phase 1: Non-interactive
    if [[ -n "$BASH_ENV" && -f "$BASH_ENV" ]]; then
        roots+=( "$BASH_ENV" )
        phase="non-interactive"
    fi

    #-------------------------------------------------------
    # Phase 2: Login shell
    if shopt -q login_shell; then
        phase="login"

        [[ -f /etc/profile ]] && roots+=( /etc/profile )
        [[ -d /etc/profile.d ]] && roots+=( /etc/profile.d/*.sh )

        if [[ -f ~/.bash_profile ]]; then
            roots+=( ~/.bash_profile )
        elif [[ -f ~/.bash_login ]]; then
            roots+=( ~/.bash_login )
        elif [[ -f ~/.profile ]]; then
            roots+=( ~/.profile )
        fi

    #-------------------------------------------------------
    # Phase 3: Interactive non-login
    elif [[ $- == *i* ]]; then
        phase="interactive"

        [[ -f /etc/bash.bashrc ]] && roots+=( /etc/bash.bashrc )
        [[ -f /etc/bashrc ]] && roots+=( /etc/bashrc )
        [[ -f ~/.bashrc ]] && roots+=( ~/.bashrc )

    
        if [[ -n "$__CA_RHEL_like" ]]; then
            # This system is Fedora/RHEL-like
            [[ -d /etc/profile.d ]] && roots+=( /etc/profile.d/*.sh )
        fi 
    fi
    
        # Restore nullglob if we changed it
    (( nullglob_was == 1 )) && shopt -u nullglob
    
    #-------------------------------------------------------
    # Static discovery pass
    for f in "${roots[@]}"; do
        _ca_sourcedtree_single "$f" 0 "$CA_MAX_DEPTH"
    done

    #-------------------------------------------------------
    # Emit ordered walk
    # Root files first, then discovered children
    for f in "${roots[@]}"; do
        f=$(_ca_expand_path "$f")
        [[ -f "$f" ]] && ordered+=( "$f" )
    done

    for f in "${__CA_SOURCED_FILES_LIST[@]}"; do
        [[ " ${ordered[*]} " != *" $f "* ]] && ordered+=( "$f" )
    done

    #-------------------------------------------------------
    # Output
    printf "├─ Examining Bash startup: (%s)\n" "$phase"                       
    local i=0
    for f in "${ordered[@]}"; do
        printf '%02d  %s\n' "$((++i))" "$f"
    done
}

#------------------------------------------------------------------------
# Function: _ca_detect_os
# detect os for differences in implementation
#------------------------------------------------------------------------
_ca_detect_os() {
        __CA_RHEL_like=0
        if [ -f /etc/os-release ]; then
            while IFS='=' read -r key value; do
                # Remove surrounding quotes if present
                value="${value%\"}"
                value="${value#\"}"
                case "$key" in
                    ID)
                        [[ "$value" == "fedora" || "$value" == "rhel" ]] && __CA_RHEL_like=1
                        ;;
                    ID_LIKE)
                        [[ "$value" == *"rhel"* ]] && __CA_RHEL_like=1
                        ;;
                esac
            done < /etc/os-release
        fi
}  

#------------------------------------------------------------------------
# End of script
