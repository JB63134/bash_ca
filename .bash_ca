#!/usr/bin/env bash
#------------------------------------------------------------------------
# .bash_ca
# Main Function: ca
# Purpose: Analyzes a Bash command, alias, builtin, keyword, function, or binary
#------------------------------------------------------------------------
# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

OLD_PATH="$PATH"

declare -gA __H_SEEN_ALIASES
declare -gA __H_SEEN_COMMANDS
declare -gA __H_SEEN_BUILTINS
declare -gA __H_SHADOW_SEEN
declare -gA __H_VISITED        # NEW: global visited set for recursion protection
declare -g suppress_builtin_msg=1   # suppress repeated builtin help
complete -F _ca_completion ca

ca() {
    # -------------------------
    # LOCAL Variables
    # -------------------------
    local fcmd cmd ctype cmd_path alias_expansion RED GREEN CYAN RESET 
    local depth=${2:-0}
    local cmdline="$*"
    local MAX_DEPTH=8
    local indent=$(printf "%*s" $((depth * 4)) "")
    
    # -------------------------
    # Set first run variables path etc... keep from running every recursive loop 
    # set new path, clean arrays, and greet user once
    # -------------------------
    if (( depth == 0 )); then
        trap 'PATH="$OLD_PATH"' RETURN

        local admin_dirs=(
            "$HOME/.local/bin"
            "$HOME/bin/scripts"
            "$HOME/bin"
            "/usr/local/bin"
            "/usr/local/sbin"
            "/usr/local/games"
            "/usr/bin"
            "/usr/sbin"        
            "/usr/games"
            "/bin"
            "/sbin"   
            )
    
        # Add admin dirs to PATH if missing
        for dir in "${admin_dirs[@]}"; do
            if [[ -d "$dir" && ":$PATH:" != *":$dir:"* ]]; then
                PATH="$PATH:$dir"
            fi
        done
        export PATH
   
        # -------------------------
        # Check dependencies
        _ca_check_dependencies needed_deps optional_deps 1  # 1 = exit if required deps missing

        #--------------------------
        # Reset arrays on first run
        #--------------------------
        __H_SEEN_ALIASES=()
        __H_SEEN_COMMANDS=()
        __H_SEEN_BUILTINS=()
        __H_SHADOW_SEEN=()
        __H_VISITED=()
   
        #--------------------------
        # Greeting
        #--------------------------
        printf "\n├─ ca - a buggy BASH Command Analyzer\n"
    fi 
    
    # -------------------------
    # Colors (tput → ANSI)
    # -------------------------
    if command -v tput &>/dev/null && [[ $(tput colors 2>/dev/null) -ge 8 ]]; then
        # Preferred: tput colors
        RED=$(tput setaf 1)
        GREEN=$(tput setaf 2)
        CYAN=$(tput setaf 6)
        YELLOW=$(tput setaf 11)
        BPURP=$(tput setaf 13)
        RESET=$(tput sgr0)
    else
        # Fallback: ANSI escape sequences
        RED='\033[31m'
        GREEN='\033[32m'
        CYAN='\033[36m'
        YELLOW='\033[93m'
        BPURP='\033[95m'
        RESET='\033[0m'
    fi
        
    # -------------------------
    # Depth guard
    # -------------------------
    (( depth > MAX_DEPTH )) && { 
        printf "%s${RED}Max recursion depth (%d) reached${RESET}\n" "$indent" "$MAX_DEPTH"
        return 1 
    }
    
    # -------------------------
    # Get command or last command
    # -------------------------
    if [[ -n "$1" ]]; then
        read -r -a fcmd <<< "$1"
    else
        read -r -a fcmd <<< "$(fc -ln -1)" || { 
            printf "%s    ↳ ${RED}Failed to get last command${RESET}\n" "$indent"
            return 1
        }
    fi
    cmd="${fcmd[0]}"
    
    # -------------------------------------------------------------------------
    # handle arguments for h
    # -------------------------------------------------------------------------
    case "$cmd" in
        -h|--help) _ca_usage; return 0;;
        -v|--version) _ca_ver; return 0;;
        -s|--sourced) printf "\n" && _ca_sourced_files; return 0;;
        -o|--overridden) printf "\n" && _ca_overridden; return 0;;
        -p|--path) printf "\n" && _ca_writable_dir_in_path; return 0;;
        -S|--suid) printf "\n" && _ca_suid_scan; return 0;;
        -f|--fzf)
            if ! command -v fzf &>/dev/null; then
                printf "fzf not installed\n"
                return 1
            fi

            local pick
            pick=$(compgen -A function -A alias -A builtin -A command | sort -u | fzf --prompt="Get help for: ")

            [[ -n "$pick" ]] || return 1
            ca "$pick"
            return 0
            ;;  
    esac
    
    # -------------------------------------------------------------------------
    # Handle h for now, prevent h from analyzing itself because 
    # it will spam the screen with itself
    # -------------------------------------------------------------------------
    if [[ "$cmd" == "h" ]]; then
            printf "%s├─ Detected ${CYAN}'%s' ${RESET}\n" "$indent" "$cmd"
            printf "%s    ↳ Showing  ${CYAN}'%s --help'${RESET}:\n\n"  "$indent" "$cmd"
            _ca_usage
            export OLD_PATH
            return 0
    fi
    if [[ "$cmd" == "]" ]]; then
        printf "%s├─ Detected BASH Keyword ${CYAN}'%s' ${RESET}\n" "$indent" "$cmd"
        printf "%s    ↳ ${CYAN}%s${RESET} -- Ends a conditional test expression.\n" "$indent" "$cmd"
        return 0
    fi
    # -------------------------------------------------------------------------
    # Split and analyze pipelines, chains, and lists safely
    # -------------------------------------------------------------------------
    if [[ "$cmdline" =~ [\|\&\;] ]]; then
        local segments=()
        _ca_split_top_level_commands "$cmdline" segments

        for seg in "${segments[@]}"; do
            # Get individual commands in the segment (e.g., within a pipeline)
            local subcmds=()
            _ca_parse_commands "$seg" subcmds

            for c in "${subcmds[@]}"; do
                printf "%s${CYAN}↳ Subcommand:${RESET} %s\n" "$indent" "$c"
                ca "$c" $((depth + 1))
            done
        done
        return 0
    fi

    # -------------------------------------------------------------------------
    # Detect command type
    # -------------------------------------------------------------------------
    ctype=$(type -t -- "$cmd" 2>/dev/null)
    if [[ -z "$ctype" ]]; then
        printf "%s├─ ${RED}Unknown or invalid command:${CYAN} '%s'${RESET}\n" "$indent" "$cmd"
        printf "%s    ↳ Check your spelling and try again\n\n" "$indent" 
        export OLD_PATH
        return 1
    fi

    # -------------------------------------------------------------------------
    # Handle keywords and provide help statements
    # -------------------------------------------------------------------------
    if [[ "$ctype" == "keyword" ]]; then
        case "$cmd" in
        if|case|for|select|while|until|function|time|{|[[|coproc)
            printf "%s├─ Detected BASH Keyword ${CYAN}'%s' ${RESET}\n" "$indent" "$cmd"
            printf "%s    ↳ Showing  ${CYAN}'help %s'${RESET}:\n\n" "$indent" "$cmd"
            help "$cmd" 2>/dev/null | sed 's/^/    /'
            return 0
            ;;
        esac
    
        case "$cmd" in
            then|else|elif|fi|do|done|in|!|])
                description=""
                case "$cmd" in
                    then) description="Begins the command block for a true condition." ;;
                    else) description="Begins the command block if the condition is false." ;;
                    elif) description="Introduces a new condition if the previous one is false." ;;
                    fi)   description="Ends an if statement." ;;
                    do)   description="Begins the body of a loop or conditional block." ;;
                    done) description="Ends the body of a loop or conditional block." ;;
                    in)   description="Specifies the list to iterate over in a loop." ;;
                    !)    description="Negates the exit status of a command or pipeline." ;;
                esac
            printf "%s├─ Detected BASH Keyword ${CYAN}'%s' ${RESET}\n" "$indent" "$cmd"
            printf "%s    ↳ ${CYAN}%s${RESET} -- %s\n" "$indent" "$cmd" "$description"
            return 0
            ;;
        esac

        if [[ "$cmd" == "esac" ]]; then
            printf "%s├─ Detected BASH Keyword ${CYAN}'%s' ${RESET}\n" "$indent" "$cmd"
            printf "%s    ↳ ${CYAN}%s${RESET} -- Ends a case statement.\n" "$indent" "$cmd"
            return 0
        fi

        if [[ "$cmd" == "}" ]]; then
            printf "%s├─ Detected BASH Keyword ${CYAN}'%s' ${RESET}\n" "$indent" "$cmd"
            printf "%s    ↳ ${CYAN}%s${RESET} -- Ends a group of commands in a block.\n" "$indent" "$cmd"
            return 0
        fi
      
        if [[ "$cmd" == "]]" ]]; then
            printf "%s├─ Detected BASH Keyword ${CYAN}'%s' ${RESET}\n" "$indent" "$cmd"
            printf "%s    ↳ ${CYAN}%s${RESET} -- Ends a conditional test expression.\n" "$indent" "$cmd"
            return 0
        fi
    fi

# -------------------------------------------------------------------------
# Builtins
# -------------------------------------------------------------------------
if [[ "$ctype" == "builtin" ]]; then
    
    # Special builtins: `builtin` and `command`
    if [[ "$cmd" == "builtin" || "$cmd" == "command" ]]; then    
        
        # Case: user typed plain `builtin` or `command`
        if (( ${#fcmd[@]} == 1 )); then
            printf "%s├─ Detected builtin ${CYAN}'%s' ${RESET}with no command\n" \
                "$indent" "$cmd"
            printf "%s    ↳ Showing  ${CYAN}'help %s'${RESET}:\n\n" \
                "$indent" "$cmd"
            help "$cmd" 2>/dev/null | sed 's/^/    /'
            return 0
        fi

        # Strip wrapper and skip flags
        local subcmd=("${fcmd[@]:1}")
        while [[ "${subcmd[0]}" == -* ]]; do
            subcmd=("${subcmd[@]:1}")
        done

        printf "%s├─ Detected ${CYAN}'%s'${RESET} wrapper\n" "$indent" "$cmd"
        printf "%s    ↳ Showing  ${CYAN}'help %s'${RESET}:\n\n" \
            "$indent" "${subcmd[0]}"

        help "${subcmd[0]}" 2>/dev/null | sed 's/^/    /'
        return 0    
    fi
    
    # Normal builtin
    printf "%s├─ ${CYAN}'%s'${RESET} is a shell builtin\n" "$indent" "$cmd"

    # Enabled/disabled
    local enabled_state="enabled"
    if enable -p 2>/dev/null | grep -qE "^-n ${cmd}\b"; then
        enabled_state="disabled"
    fi
    printf "%s    ↳ Status: Shell builtin is ${CYAN}%s${RESET}\n" \
        "$indent" "$enabled_state"

    # Loadable builtins
    local origin="Core Bash builtin"
    while read -r loaded; do
        # format: enable -f PATH NAME
        builtin_name="${loaded##* }"
        if [[ "$builtin_name" == "$cmd" ]]; then
            origin="Loadable builtin ($loaded)"
            break
        fi
    done < <(enable -a | grep '^enable -f ' || true)

    printf "%s    ↳ Source:  ${CYAN}%s${RESET}\n" "$indent" "$origin"


    # Show help
    printf "%s    ↳ Showing ${CYAN}'help %s'${RESET}:\n\n" \
        "$indent" "$cmd"
    help "$cmd" 2>/dev/null | sed "s/^/$indent        /"

    # Recurse
    local nextcmd=("${fcmd[@]:1}")
    if (( ${#nextcmd[@]} > 0 )); then
        ca "${nextcmd[*]}" $((depth + 1))
    fi

    return 0
fi
        
    # -------------------------------------------------------------------------
    # Functions
    # -------------------------------------------------------------------------
    if [[ "$ctype" == "function" ]]; then

        #--------------------------- 
        # Enable extdebug temporarily so declare -F includes file/line info
        local was_extdebug=0
        shopt -q extdebug && was_extdebug=1 || shopt -s extdebug
        
        read _ line file <<< "$(declare -F "$cmd")"

        (( !was_extdebug )) && shopt -u extdebug  # Restore extdebug state if we enabled it
        #---------------------------- 
        
        printf "%s├─ ${CYAN}'%s' ${RESET}is a shell function\n" "$indent" "$cmd"
        printf "%s    ↳ Declared in: ${CYAN}%s (line %s)${RESET}\n" "$indent" "$file" "$line"
        printf "%s    ↳ Showing function: ${CYAN}%s${RESET}\n\n"  "$indent" "$cmd"        
        func_content=$(declare -f "$cmd")
        _ca_highlight_script "$func_content" "$indent"
        printf "\n%s    ─── End of function '%s' ───\n" "$indent" "$cmd"    
        return 0
    fi
    
    # -------------------------------------------------------------------------
    # Aliases
    # -------------------------------------------------------------------------
    if [[ "$ctype" == "alias" ]]; then
        # Avoid re-analyzing the same alias (prevents infinite loops)
        [[ -n "${__H_SEEN_ALIASES[$cmd]}" ]] && return 0
        __H_SEEN_ALIASES["$cmd"]=1
    
        # Get the alias expansion (strip surrounding quotes)
        raw=$(alias "$cmd")
        alias_expansion=${raw#*=}         # remove 'name='
        alias_expansion=${alias_expansion:1:${#alias_expansion}-2}   # trim outer quotes

        # Expand environment vars safely (no command execution)
        alias_expansion=$(_ca_expand_vars "$alias_expansion")
  
        alias_def=$(alias "$cmd")
        printf "%s├─ ${CYAN}'%s' ${RESET}is an alias → resolves to: ${CYAN}%s${RESET}\n" "$indent" "$cmd" "$alias_def"
    
        # Show where alias is defined
        local found_location=""
        local line_number
        
        _ca_sourcedtree
        
        #----------------------------
        # Enable nullglob temporarily 
        local nullglob_was=0
        shopt -q nullglob && nullglob_was=1 || shopt -s nullglob      
        for file in ${SOURCED_FILES_LIST[@]}; do 
             [[ -r "$file" ]] || continue
             if grep -qE "^[[:space:]]*alias[[:space:]]+${cmd}=" "$file"; then
                found_location="$file"
                line_number=$(grep -nE "^[[:space:]]*alias[[:space:]]+$cmd=" "$file" | head -n1 | cut -d: -f1)
                printf "%s    ↳ Defined in: ${CYAN}%s (line %s)${RESET}\n" "$indent" "$file" "$line_number"
             fi
        done
        (( !nullglob_was )) && shopt -u nullglob           # Restore nullglob state if we enabled it
        #----------------------------
        
        if [[ -z "$found_location" ]]; then
            printf "%s    ↳ Defined manually in shell, or a custom location.\n" "$indent"
        fi     
    
        # Handle alias expansion with chain/pipeline parsing
        if [[ "$alias_expansion" =~ [\|\&\;] ]]; then
            local segments=()
            _ca_split_top_level_commands "$alias_expansion" segments

            for seg in "${segments[@]}"; do
                local subcmds=()
                _ca_parse_commands "$seg" subcmds

                for c in "${subcmds[@]}"; do
                    printf "%s${BPURP}    ↳ Alias subcommand:${RESET} %s\n" "$indent" "$c"
                    ca "$c" $((depth + 1))
                done
            done
            return 0
        else
            # No chain/pipeline — analyze normally
            # Resolve only the first token of the alias expansion to avoid arbitrary shells
            read -r -a alias_tokens <<< "$alias_expansion"
            local primary="${alias_tokens[0]}"
            # If primary is a function, recurse; otherwise analyze as external or builtin
            if declare -F "$primary" &>/dev/null; then
                if [[ -z "${__H_VISITED[$primary]}" ]]; then
                    __H_VISITED["$primary"]=1
                    ca "$primary" $((depth + 1))
                else
                    printf "%s    ↳ ${CYAN}%s${RESET} already visited — possible cycle\n" "$indent" "$primary"
                fi
            else
                ca "$alias_expansion" $((depth + 1))
            fi
            return 0
        fi
    fi

    # -------------------------------------------------------------------------
    # External commands
    # -------------------------------------------------------------------------
    if [[ "$ctype" == "file" ]]; then 
        cmd_path=$(command -v "$cmd") || { 
            printf "%s${RED}Command not found: '%s'${RESET}\n" "$indent" "$cmd"
            return 1
        }
        local cmd_real formatted_type             
        cmd_real=$(readlink -f "$cmd_path" 2>/dev/null || echo "$cmd_path")
        file_info=$(file -b "$cmd_real")

        # Replace commas with newlines for clarity, but keep first line aligned
        formatted_type=$(printf "%s" "$file_info" | sed -E $'s/, interpreter/\\\ninterpreter/g; s/, version/\\\nversion/g; s/, dynamically/\\\ndynamically/g; s/, BuildID/\\\nBuildID/g; s/, for /\\\nfor /g')
        
        printf "%s├─ ${CYAN}'%s' ${RESET}is an external command\n" "$indent" "$cmd"
        printf "%s    ↳ Path: ${CYAN}%s${RESET}\n" "$indent" "$cmd_path"    
  
        if [[ "$cmd_real" != "$cmd_path" ]]; then # && \
            printf "%s    ↳ ${YELLOW}Symbolic link ${RESET}to: ${YELLOW}%s${RESET}\n" "$indent" "$cmd_real"
            cmd_path="$cmd_real"
            printf "%s    ↳ Now Examining: ${BPURP}%s${RESET}\n" "$indent" "$cmd_real"
        fi
 
        # Root privilege detection 
        local requires_root=0
        local root_reason=""
        # 1. Check for setuid root
        if [[ -u "$cmd_path" && $(stat -c '%U' "$cmd_path" 2>/dev/null) == "root" ]]; then
            requires_root=1
            root_reason="setuid root binary"
        # 2. Check capabilities with getcap
        elif command -v getcap &>/dev/null; then
            local caps
            caps=$(getcap "$cmd_path" 2>/dev/null)
            if [[ "$caps" =~ (cap_sys_admin|cap_dac_override|cap_net_admin) ]]; then
                requires_root=1
                root_reason="binary grants elevated capabilities (getcap)"
            fi
        fi
        # 3. Check capabilities using capsh if available
        if (( !requires_root )) && command -v capsh &>/dev/null; then(
            local cap_info
            cap_info=$(capsh --print 2>/dev/null)
    
            if [[ "$cap_info" =~ "Current:" ]]; then
                if [[ "$cap_info" =~ (cap_sys_admin|cap_dac_override|cap_net_admin) ]]; then
                    requires_root=1
                    root_reason="binary requires elevated capabilities (capsh)"
                fi
            fi)
        fi
        # 4. Known admin commands
        if (( !requires_root )); then
            local root_cmds=(mount umount reboot shutdown halt ifconfig iptables ip systemctl journalctl modprobe insmod rmmod fdisk mkfs losetup parted fsck useradd userdel passwd chown chmod service sysctl visudo fstrim swapoff swapon update-grub grub-install blkid update-initramfs)
            for rcmd in "${root_cmds[@]}"; do
                if [[ "$cmd" == "$rcmd" ]]; then
                    requires_root=1
                    root_reason="known administrative command"
                    break
                fi
            done
        fi
        # 5. Display result
        if (( requires_root )); then
            printf "%s    ↳ Requires root privileges: ${YELLOW}Yes (%s)${RESET}\n" "$indent" "$root_reason"
        else
            printf "%s    ↳ Requires root privileges: ${CYAN}No${RESET}\n" "$indent"
        fi
 
        # Detect Executable Type
        if grep -qi 'ELF' <<< "$file_info"; then
            if grep -qi 'statically linked' <<< "$file_info"; then
                printf "%s    ↳ Executable Type: ELF binary - Statically linked\n" "$indent"
                while IFS= read -r line; do
                    printf "%s    ⎟    ${CYAN}%s${RESET}\n" "$indent" "$line"
                done <<< "$formatted_type"
            else
                printf "%s    ↳ Executable Type: ELF binary - Dynamically linked\n" "$indent"  
                while IFS= read -r line; do
                    printf "%s    ⎟    ${CYAN}%s${RESET}\n" "$indent" "$line"
                done <<< "$formatted_type"  
            fi

        elif grep -qi 'script\|text executable' <<< "$file_info"; then
            printf "%s    ↳ Executable Type: ${CYAN}Script / Text executable${RESET}\n" "$indent"

            local first_line interp
            first_line=$(head -n1 "$cmd_path")

            if [[ "$first_line" =~ ^#! ]]; then
                interp="${first_line#\#!}"        # remove shebang (#!)
                interp="${interp#"${interp%%[![:space:]]*}"}"  # trim leading whitespace
                while IFS= read -r line; do
                    printf "%s    ⎟    ${CYAN}%s${RESET}\n" "$indent" "$line"
                done <<< "$formatted_type"       
            fi
            printf "%s    ↳ Interpreter: ${CYAN}%s${RESET}\n" "$indent" "$interp"
        else
            printf "%s    ↳ Executable Type: Unknown\n" "$indent"
            while IFS= read -r line; do
                printf "%s    ⎟    ${CYAN}%s${RESET}\n" "$indent" "$line"
            done <<< "$formatted_type"
            printf "%s    ⎟       ${YELLOW}%s${RESET}\n" "$indent" "$file_info"
        fi
   
        # Get dependencies
        deps=$(ldd "$cmd_path" 2>/dev/null | sed 's/^[[:space:]]*//')
        if [[ -n "$deps" ]]; then
            printf "%s    ↳ Dependencies:\n" "$indent" 
            local unmet_found=0
            while IFS= read -r line; do
                if [[ "$line" =~ "not found" ]]; then
                    unmet_found=1
                    printf "%s    ⎟    ${RED}%s${RESET}\n" "$indent" "$line"
                else
                    printf "%s    ⎟    ${CYAN}%s${RESET}\n" "$indent" "$line"
                fi
            done <<< "$deps"
            (( unmet_found )) && printf "%s        ↳ ${RED}⚠ Some dependencies are missing!${RESET}\n" "$indent"
        fi

        # Package info---------------
        local pkg_name
        local pkg_lines=()

        if command -v dpkg &>/dev/null; then
            pkg_name=$(dpkg -S "$cmd_path" 2>/dev/null | cut -d: -f1 | head -n1)

            if [[ -n "$pkg_name" ]]; then
                # Read dpkg show output line by line
                while IFS= read -r line; do
                    pkg_lines+=("$line")
                done < <(dpkg-query -W -f='${Package}\n${Version}\n${Maintainer}\n${Description}\n' "$pkg_name" 2>/dev/null)
                
                # Display each line with custom formatting
                printf "%s    ↳ Package Info:\n" "$indent"
                printf "%s    ⎟    Package: ${CYAN}%s${RESET}\n" "$indent" "${pkg_lines[0]}"
                printf "%s    ⎟    Version: ${CYAN}%s${RESET}\n" "$indent" "${pkg_lines[1]}"
                printf "%s    ⎟    Maintainer: ${CYAN}%s${RESET}\n" "$indent" "${pkg_lines[2]}"
                printf "%s    ⎟    Description: ${CYAN}%s${RESET}\n" "$indent" "${pkg_lines[3]}"
            fi
        fi

        # Get and display file permissions
        if [[ -x "$cmd_path" ]]; then
            local perms octal owner_grp owner_perm group_perm other_perm
            # Using stat for symbolic and octal
            if stat --version &>/dev/null; then
                perms=$(stat -c "%A" "$cmd_path")      # symbolic: -rwxr-xr-x
                octal=$(stat -c "%a" "$cmd_path")      # numeric: 755
                owner_grp=$(stat -c "%U:%G" "$cmd_path") # owner:group
                owner_perm=$(stat -c "%A" "$cmd_path" | cut -c2-4)   # owner bits
                group_perm=$(stat -c "%A" "$cmd_path" | cut -c5-7)   # group bits
                other_perm=$(stat -c "%A" "$cmd_path" | cut -c8-10)  # others bits
            fi

            printf "%s    ↳ Permissions: ${CYAN}%s${RESET} (octal: ${CYAN}%s${RESET})\n" "$indent" "$perms" "$octal"
            printf "%s         ↳ Owner/Group: ${CYAN}%s${RESET}\n" "$indent" "$owner_grp"
            printf "%s         ↳ Owner: ${CYAN}%s${RESET}  Group: ${CYAN}%s${RESET}  Others: ${CYAN}%s${RESET}\n" \
            "$indent" "$owner_perm" "$group_perm" "$other_perm"
            fi
   
        # Show script contents if text executable
        if [[ "$file_info" == *"script"* || "$file_info" == *"text executable"* ]]; then
            printf "%s    ↳ Showing script ${CYAN}'%s'${RESET}:\n\n" "$indent" "$cmd"
            if [[ -r "$cmd_path" ]]; then
                _ca_highlight_script "$cmd_path" "$indent"
                printf "\n\n%s    ─── End of script '%s' ───\n" "$indent" "$cmd"
            fi
            return 0
        fi

        local next_cmd=("${fcmd[@]:1}")
        if (( ${#next_cmd[@]} > 0 )); then
            ca "${next_cmd[*]}" $((depth + 1))
        fi
    
        export OLD_PATH 
        return 0
    fi
}
 
#------------------------------------------------------------------------
# Function: _h-usage
# Purpose : Display usage information and examples for the `h` command analyzer.
#------------------------------------------------------------------------
_ca_usage() {
    cat <<'EOF'

     Usage:  ca [command]  
     Analyzes a Bash command, alias, builtin, function, or binary — showing where it’s defined,
     how it expands, and what help or documentation is available.

     Options:
           -h --help or h      Show this help text.
           -v --version        Show version information.
           -s --sourced        List all sourced files in the enviroment.
           -o --overridden     List all commands that override a command in the enviroment.
           -p --path           list all writable directories in $PATH
           -S --suid           Scan for SUID binaries
           
     Examples:
           ca                   # Automatically analyzes your most recent command
           ca sudo              # Analyzes 'sudo'
           ca 'sudo rm'         # Ignores sudo and Analyzes rm
           ca ls                # Is 'ls' a builtin, keyword, alias, function, script or binary?

     Features:
       • Handles builtins, aliases, keywords, functions, and external commands
       • Syntax-highlighted preview of functions and scripts
       • Shows --help/-help/-h/-? output or points to man pages
  
EOF
}

#------------------------------------------------------------------------
# Function: _h-ver
# Purpose : Display version information.
#------------------------------------------------------------------------
_ca_ver() {
    cat <<'EOF'

     h v1.1.15 — Bash Command Analyzer
     Author : John Blair
     Updated: 2025-11-10  
          
     MIT License

     Copyright (c) 2025 John Blair

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in all
     copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     SOFTWARE.

EOF
}

#------------------------------------------------------------------------
# Function: _ca_suid_scan
# Purpose : Scan for SUID binaries
#------------------------------------------------------------------------
_ca_suid_scan() {
    printf "├─ Scanning for SUID binaries:\n"

    while IFS= read -r hit; do
        printf "    ↳ %s\n" "$hit"
    done < <(find / -perm -4000 -type f -exec ls -l {} + 2>/dev/null)
}
_ca_suid_scan2() {
    printf "├─ Scanning for SUID binaries (parallelized):\n"

    # Export function for xargs (optional if using simple command)
    export -f

    # Find SUID files and list them in parallel
    find / -perm -4000 -type f 2>/dev/null \
        | xargs -P 8 -I {} ls -l {} 2>/dev/null \
        | while IFS= read -r hit; do
            printf "    ↳ %s\n" "$hit"
        done
}
#------------------------------------------------------------------------
# Function: _ca_writable_dir_in_path
# Purpose : Detect writable directories in $PATH
#------------------------------------------------------------------------
_ca_writable_dir_in_path() {
    PATH="$OLD_PATH" 
    printf "├─ Examining PATH:\n"
    printf "├─ Identifying writable directories:\n"

    # List all writable directories quickly
    printf "%s\n" ${PATH//:/ } |
    while read -r d; do
        [ -d "$d" ] || continue
        if [ -w "$d" ]; then
            printf "    ↳ ${YELLOW}Writable directory in PATH: ${CYAN}%s${RESET}\n" "$d"
        fi
    done

    printf "\n├─ Examining PATH directory permissions:\n"
    printf "    ↳ %-40s %-15s %-20s %-10s\n" "Directory" "Perms" "Owner:Group" "Note"
    
    IFS=: read -ra dirs <<< "$PATH"
    for dir in "${dirs[@]}"; do
        [ -d "$dir" ] || continue

        perms=$(stat -c "%A" "$dir")
        owner_g=$(stat -c "%U:%G" "$dir")
        
        note=""

        # Check if world-writable (other write bit set)
        if [ -w "$dir" ] && [ "${perms:8:1}" = "w" ]; then
            note="${BPURP}WORLD-WRITABLE${RESET}"
            printf "    ↳ ${RED}%-40s %-15s %-20s ${RESET}%-10s\n" "$dir" "$perms" "$owner_g" "$note"
        elif [ -w "$dir" ]; then
            note="Writable"
            printf "    ↳ ${YELLOW}%-40s %-15s %-20s %-10s${RESET}\n" "$dir" "$perms" "$owner_g" "$note"
        else
            printf "    ↳ %-40s %-15s %-20s %-10s\n" "$dir" "$perms" "$owner_g" "$note"
        fi
    done
}

#------------------------------------------------------------------------
# Function: _ca_split_top_level_commands
# Purpose : Split a Bash command line into top-level segments
#------------------------------------------------------------------------
_ca_split_top_level_commands() {
    local input="$1"
    local -n out="$2"
    out=()

    local len=${#input}
    local i=0
    local seg=""
    local c next

    # parser state
    local in_single=0 in_double=0 in_backtick=0
    local paren=0 brace=0 bracket=0
    local dollar_paren=0

    while (( i < len )); do
        c="${input:i:1}"
        next="${input:i+1:1}"

        # -----------------------------
        # QUOTE HANDLING
        # -----------------------------
        if (( in_single )); then
            seg+="$c"
            [[ $c == "'" ]] && in_single=0
            ((i++)); continue
        fi
        if (( in_double )); then
            seg+="$c"
            # handle escaped quotes inside double quotes
            if [[ $c == '"' ]] && [[ "${input:i-1:1}" != '\' ]]; then
                in_double=0
            fi
            ((i++)); continue
        fi
        if (( in_backtick )); then
            seg+="$c"
            [[ $c == '`' ]] && in_backtick=0
            ((i++)); continue
        fi

        # Enter quotes
        case "$c" in
            "'") in_single=1; seg+="$c"; ((i++)); continue;;
            '"') in_double=1; seg+="$c"; ((i++)); continue;;
            '`') in_backtick=1; seg+="$c"; ((i++)); continue;;
        esac

        # -----------------------------
        # STRUCTURAL NESTING
        # -----------------------------
        case "$c" in
            '(')
                seg+="$c"
                ((paren++))
                # detect $(...)
                if [[ "${input:i-1:1}" == '$' ]]; then ((dollar_paren++)); fi
                ((i++)); continue;;
            ')')
                seg+="$c"
                if (( dollar_paren > 0 )); then
                    ((dollar_paren--))
                else
                    ((paren--))
                fi
                ((i++)); continue;;

            '{') seg+="$c"; ((brace++)); ((i++)); continue;;
            '}') seg+="$c"; ((brace--)); ((i++)); continue;;
            '[') seg+="$c"; ((bracket++)); ((i++)); continue;;
            ']') seg+="$c"; ((bracket--)); ((i++)); continue;;
        esac

        # -----------------------------
        # TOP LEVEL OPERATORS
        # -----------------------------
        # Only if ALL nesting == 0
        if (( paren==0 && brace==0 && bracket==0 && !in_single && !in_double && !in_backtick )); then

            # Operators: || && | ; &
            # Identify multi-char first
            if [[ "$c$next" =~ ^(\|\||&&|;;|;&)$ ]]; then
                out+=("$(printf '%s' "$seg" | sed 's/[[:space:]]*$//')")
                out+=("$c$next")
                seg=""
                ((i+=2)); continue
            fi

            case "$c" in
                '|'|';'|'&')
                    out+=("$(printf '%s' "$seg" | sed 's/[[:space:]]*$//')")
                    out+=("$c")
                    seg=""
                    ((i++)); continue;;
            esac
        fi

        # default → accumulate
        seg+="$c"
        ((i++))
    done

    # final segment
    if [[ -n "$seg" ]]; then
        out+=("$(printf '%s' "$seg" | sed 's/[[:space:]]*$//')")
    fi
}

#------------------------------------------------------------------------
# Function: _ca_parse_commands
# Purpose : Parse a Bash segment into actual executed commands using a conservative tokenizer
#------------------------------------------------------------------------
_ca_parse_commands() {
    local cmdline="$1"
    local -n out_arr="${2:-out_arr}" 2>/dev/null || local -n out_arr="$2"
    [[ -z "$cmdline" ]] && return

    local segments=()
    local seg=""
    local in_single=0 in_double=0
    local in_backtick=0
    local paren=0 brace=0 bracket=0
    local i=0 len=${#cmdline} c next

    # First, split by top-level operators
    while (( i < len )); do
        c="${cmdline:i:1}"
        next="${cmdline:i+1:1}"

        # Handle quotes
        if (( in_single )); then
            seg+="$c"
            [[ $c == "'" ]] && in_single=0
            ((i++)); continue
        fi
        if (( in_double )); then
            seg+="$c"
            if [[ $c == '"' && "${cmdline:i-1:1}" != '\' ]]; then
                in_double=0
            fi
            ((i++)); continue
        fi
        if (( in_backtick )); then
            seg+="$c"
            [[ $c == '`' ]] && in_backtick=0
            ((i++)); continue
        fi

        case "$c" in
            "'") in_single=1; seg+="$c"; ((i++)); continue;;
            '"') in_double=1; seg+="$c"; ((i++)); continue;;
            '`') in_backtick=1; seg+="$c"; ((i++)); continue;;
            '(') ((paren++)); seg+="$c"; ((i++)); continue;;
            ')') ((paren--)); seg+="$c"; ((i++)); continue;;
            '{') ((brace++)); seg+="$c"; ((i++)); continue;;
            '}') ((brace--)); seg+="$c"; ((i++)); continue;;
            '[') ((bracket++)); seg+="$c"; ((i++)); continue;;
            ']') ((bracket--)); seg+="$c"; ((i++)); continue;;
        esac

        # Top-level operator detection
        if (( paren==0 && brace==0 && bracket==0 && !in_single && !in_double && !in_backtick )); then
            if [[ "$c$next" =~ ^(\|\||&&)$ ]]; then
                [[ -n "$seg" ]] && segments+=("$seg")
                segments+=("$c$next")
                seg=""
                ((i+=2))
                continue
            fi
            case "$c" in
                '|'|';'|'&')
                    [[ -n "$seg" ]] && segments+=("$seg")
                    segments+=("$c")
                    seg=""
                    ((i++))
                    continue;;
            esac
        fi

        # default → accumulate
        seg+="$c"
        ((i++))
    done
    [[ -n "$seg" ]] && segments+=("$seg")

    # Now analyze each segment
    for s in "${segments[@]}"; do
        # Operators
        if [[ "$s" =~ ^(\|\||&&|;|\|)$ ]]; then
            out_arr+=("$s")
            continue
        fi

        # Split segment into command + args respecting quotes (simple)
        local tokens=()
        # Use a safe read to split tokens: rely on word-splitting via eval in a subshell but avoid execution
        # We use printf %q + eval with "set --" to safely split respecting quotes (no expansion)
        local raw="$s"
        # remove leading/trailing whitespace
        raw="${raw#"${raw%%[![:space:]]*}"}"
        raw="${raw%"${raw##*[![:space:]]}"}"
        if [[ -z "$raw" ]]; then
            continue
        fi

        # attempt a conservative split
        local token=""
        local j=0 len_seg=${#raw} ch
        local in_s=0 in_d=0
        while (( j < len_seg )); do
            ch="${raw:j:1}"
            if (( in_s )); then
                token+="$ch"
                [[ $ch == "'" ]] && in_s=0
                ((j++)); continue
            fi
            if (( in_d )); then
                token+="$ch"
                if [[ $ch == '"' && "${raw:j-1:1}" != '\' ]]; then
                    in_d=0
                fi
                ((j++)); continue
            fi

            case "$ch" in
                "'") in_s=1; token+="$ch";;
                '"') in_d=1; token+="$ch";;
                ' ')
                    if [[ -n "$token" ]]; then
                        tokens+=("$token")
                        token=""
                    fi
                    ;;
                *) token+="$ch";;
            esac
            ((j++))
        done
        [[ -n "$token" ]] && tokens+=("$token")

        # Analyze first token as command
        local cmd_name="${tokens[0]}"
        # normalize: strip surrounding quotes if present
        if [[ "$cmd_name" =~ ^\".*\"$ || "$cmd_name" =~ ^\'.*\'$ ]]; then
            cmd_name="${cmd_name:1:${#cmd_name}-2}"
        fi
        local args=("${tokens[@]:1}")

        # Skip already seen alias recursion in this parse (avoid infinite)
        if [[ -n "${__H_SEEN_ALIASES[$cmd_name]}" ]]; then
            out_arr+=("$cmd_name")
            continue
        fi

        if alias "$cmd_name" &>/dev/null; then
            __H_SEEN_ALIASES[$cmd_name]=1
            local expansion
            expansion=$(alias "$cmd_name" | sed -E "s/^alias $cmd_name='(.*)'$/\1/")
            out_arr+=("$cmd_name")
            # we do not expand inline here — return token to caller for further analysis
        elif declare -f "$cmd_name" &>/dev/null; then
            __H_SEEN_ALIASES[$cmd_name]=1
            out_arr+=("$cmd_name")
        else
            out_arr+=("$cmd_name")
        fi
    done
}

#------------------------------------------------------------------------
# Function: _ca_completion
# Purpose : Enable tab completion for entering commands 
#------------------------------------------------------------------------
_ca_completion() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local commands

    # Collect possible completions: aliases, functions, builtins, and executables in PATH
    commands=$(compgen -A function -A alias -A builtin -A command -- "$cur")

    # Return completions
    COMPREPLY=( $(compgen -W "$commands" -- "$cur") )
}

#------------------------------------------------------------------------
# Function: _ca_expand_vars
# Purpose : expand variables for aliases so $HOME resolves to /home/jb/ 
#------------------------------------------------------------------------
_ca_expand_vars() {
    local input="$1"
    # Only expand variables like $HOME, $USER, etc. Use 'printf' with parameter expansion to avoid arbitrary command execution.
    # Use a small whitelist: HOME, USER, PWD, SHELL
    local out="$input"
    [[ -n "$HOME" ]] && out="${out//\$HOME/$HOME}"
    [[ -n "$USER" ]] && out="${out//\$USER/$USER}"
    [[ -n "$PWD" ]] && out="${out//\$PWD/$PWD}"
    [[ -n "$SHELL" ]] && out="${out//\$SHELL/$SHELL}"
    printf '%s' "$out"
}

#------------------------------------------------------------------------
# Function: _ca_sourcedtree
# Purpose: Recursively scan .bashrc for ALL files that are sourced. including conditionals.
#------------------------------------------------------------------------
# Global array to track all sourced files
declare -gA SOURCED_FILES_MAP=()   # associative array to avoid duplicates
declare -ga SOURCED_FILES_LIST=()  # optional list preserving order

_ca_sourcedtree() {
    SOURCED_FILES_MAP=()
    SOURCED_FILES_LIST=()
    local file files depth max_depth
    depth=0
    max_depth="${MAX_DEPTH:-5}"
    
    shopt -s nullglob
    files=(~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc ~/.bash_aliases ~/.bash_functions ~/.bash_exports ~/.bash_local ~/.local/share/bash-completion/bash_completion /etc/profile /etc/bash.bashrc /etc/bashrc /etc/profile.d/ /usr/share/bash-completion/bash_completion ~/.config/bash/bashrc ~/.bash/bashrc ~/.dotfiles/bash/ ~/.dotfiles/bashrc ~/.oh-my-bash/oh-my-bash.sh ~/.bash_it/bash_it.sh ~/.conda/etc/profile.d/conda.sh ~/.config ~/.bash_env /etc/profile.d/*.sh $BASH_ENV) 
    shopt -u nullglob

    for file in "${files[@]}"; do
        _ca_sourcedtree_single "$file" "$depth" "$max_depth"
    done
}

    #-----------------------------------------------------------
    # Internal recursive function
_ca_sourcedtree_single() {
    local file="${1:-$HOME/.bashrc}"
    local depth="${2:-0}"
    local max_depth="${3:-5}"
    local indent="" i expanded src

    (( depth > max_depth )) && return

    for ((i = 0; i < depth; i++)); do indent+="  "; done

    expanded=$(_ca_expand_path "$file")

    # Skip duplicates
    [[ -n ${SOURCED_FILES_MAP["$expanded"]} ]] && return

    # count “garbage” paths
    if [[ ! -f "$expanded" || "$expanded" =~ [\$\*\?\[\]] ]]; then
        return
    fi
    
    SOURCED_FILES_MAP["$expanded"]=1
    SOURCED_FILES_LIST+=("$expanded")

    # Extract sourced files
    while IFS= read -r src; do
        [[ $src =~ ^[[:space:]]*# ]] && continue
        [[ $src =~ (^|[[:space:]])(source|\.)[[:space:]]+([^#;]+) ]] || continue
        src="${BASH_REMATCH[3]}"
        src=$(_ca_expand_path "$src")
        _ca_sourcedtree_single "$src" $((depth + 1)) "$max_depth"
    done < <(grep -E '^\s*(\.|source)\s+' "$expanded" 2>/dev/null)
}

    #-----------------------------------------------------------
    # Helper: _ca_expand_path
_ca_expand_path() {
    local p="$1"

    # Strip quotes and whitespace
    p="${p//\"/}"
    p="${p//\'/}"
    p="${p//;/}"
    p="${p##*( )}"
    p="${p%%*( )}"

    # Tilde expansion
    [[ "$p" == "~"* ]] && p="${p/#\~/$HOME}"

    # Replace known environment variables
    [[ -n "$HOME" ]] && p="${p//\$HOME/$HOME}"
    [[ -n "$BASH_ENV" ]] && p="${p//\$BASH_ENV/$BASH_ENV}"

    # Convert to absolute path if possible
    if command -v realpath &>/dev/null && [[ -e "$p" ]]; then
        p=$(realpath "$p" 2>/dev/null || echo "$p")
    fi

    printf '%s\n' "$p"
}

#------------------------------------------------------------------------
# Function: _ca_sourced_files
# Purpose: display ALL files that are sourced.
#------------------------------------------------------------------------
_ca_sourced_files() {
    local garbage_count=${#garbage[@]}
    _ca_sourcedtree
    
    printf "%s├─ Searching for files that have been sourced into the enviroment automatically\n" 
    printf "    ↳ Discovered the following files:\n\n" 
    for file in "${SOURCED_FILES_LIST[@]}"; do
        printf "      ${CYAN}%s${RESET}\n" "$file" 
    done
    printf "\n      End of list\n"
}        

#------------------------------------------------------------------------
# Function: _ca_highlight_script   # _ca_highlight_script "$path-to-script" "<blankspaces>"
# Purpose: Modular syntax highlighting with indentation based on string in $2
#
#        how to add patterns and colors for highlighting
#
#  Example usage: To highlight the word forecast in bright magenta:
#  HIGHLIGHT_PATTERNS+=('\bforecast\b') # your_regex_here
#  HIGHLIGHT_COLORS+=('\x1b[95m')   # bright magenta - choose the ANSI color
#
#  Make sure that HIGHLIGHT_PATTERNS and HIGHLIGHT_COLORS remain aligned by index 
#  (pattern i uses color i).
#
#  Multiple new entries: 
#  HIGHLIGHT_PATTERNS+=('\bforecast\b' '\bradar\b') # Highlight 'forecast' and 'radar'
#  HIGHLIGHT_COLORS+=('\x1b[95m' '\x1b[92m')  # bright magenta & bright green
#------------------------------------------------------------------------
_ca_highlight_script() {
    local input="$1"
    local indent="${2:-}"
    local highlighted
    local use_color=1
    local esc=$'\x1b'

    # Disable color if stdout is not a terminal
    [[ ! -t 1 ]] && use_color=0

    # Read content safely
    if [[ -f "$input" ]]; then
        highlighted=$(<"$input")
    else
        highlighted="$input"
    fi

    # Highlight patterns
    declare -a HIGHLIGHT_PATTERNS=(
        '#.*'                                 # comments
        '"[^"]*"|'\''[^'\'']*'\'''            # strings
        '\$\([^)]*\)|`[^`]*`'                 # subshells
        '\b(local|declare|export|typeset)\b'  # declarations
        '\b(if|then|else|elif|fi|for|while|do|done|until|select|case|esac|break|continue)\b' # control
        '\b(function|return|exit|trap|shift|read|mapfile|set|unset)\b' # builtins
        '\b(printf|echo|mkdir|find|grep|sed|awk|cut|sort|head|tail|xargs|cat|touch|chmod|chown|curl|wget)\b' # commands
        '\$[A-Za-z0-9_@#*!?_-]+'             # variables
        '\b[0-9]+(\.[0-9]+)?\b|0x[0-9A-Fa-f]+' # numbers
        '\[\[|\]\]|\(\(|\)\)|\(|\)|\{|\}'     # brackets/parens/braces
    )

    declare -a HIGHLIGHT_COLORS=(
        "${esc}[36m"    # comments — cyan
        "${esc}[96m"    # strings — bright cyan
        "${esc}[35m"    # subshells — magenta
        "${esc}[32m"    # declarations — green
        "${esc}[93m"    # control — yellow
        "${esc}[32m"    # builtins — green
        "${esc}[35m"    # common commands — magenta
        "${esc}[33m"    # variables — yellow
        "${esc}[34m"    # numbers — blue
        "${esc}[37m"    # brackets — gray
    )

    # Disable colors if needed
    if (( use_color == 0 )); then
        for i in "${!HIGHLIGHT_COLORS[@]}"; do
            HIGHLIGHT_COLORS[$i]=""
        done
    fi

    # Apply highlighting patterns
    for i in "${!HIGHLIGHT_PATTERNS[@]}"; do
        local pattern="${HIGHLIGHT_PATTERNS[$i]}"
        local color="${HIGHLIGHT_COLORS[$i]}"
        highlighted=$(echo "$highlighted" | sed -E "s/($pattern)/${color}\1${esc}[0m/g")
    done

    # Print with indentation
    printf "%s\n" "$highlighted" | sed "s/^/$indent    /"
}

#------------------------------------------------------------------------
# Function: _ca_check_dependencies
# Purpose : Check core and optional dependencies, warn user, optionally exit on missing core deps
# Usage   : _ca_check_dependencies needed_deps optional_deps [EXIT_ON_MISSING] 0or1
#------------------------------------------------------------------------

needed_deps=(grep sed head readlink file ldd getcap)
optional_deps=(dpkg find realpath cut awk xargs tput)

_ca_check_dependencies() {
    local -n required="$1"    # Required dependencies (pass by name)
    local -n optional="$2"    # Optional dependencies (pass by name)
    local exit_on_missing="${3:-1}"  # Default: exit if required deps missing

    local missing_required=()
    local missing_optional=()

    # Check required dependencies
    for cmd in "${required[@]}"; do
        command -v "$cmd" >/dev/null 2>&1 || missing_required+=("$cmd")
    done

    # Check optional dependencies
    for cmd in "${optional[@]}"; do
        command -v "$cmd" >/dev/null 2>&1 || missing_optional+=("$cmd")
    done

    # Report missing required deps
    if (( ${#missing_required[@]} )); then
        printf "${RED}Warning: Missing REQUIRED tools: %s${RESET}\n" "${missing_required[*]}"
        printf "Some core features of the script may not work!\n"
        (( exit_on_missing )) && { printf "Exiting due to missing core dependencies.\n"; exit 1; }
    fi

    # Report missing optional deps
    if (( ${#missing_optional[@]} )); then
        printf "${YELLOW}Note: Missing optional tools: %s${RESET}\n" "${missing_optional[*]}"
        printf "Some optional features may not work.\n"
    fi

}

#------------------------------------------------------------------------
# Function: _ca_overridden                         
# Purpose : list all commands that override another command
#------------------------------------------------------------------------
_ca_overridden() {
    _ca_alias_override
    printf "\n"  
    _ca_function_override
    printf "\n"  
    _ca_builtin_override
}

#------------------------------------------------------------------------
# Function: _ca_alias_override                         
# Purpose : list all aliases that override a command
#------------------------------------------------------------------------
_ca_alias_override() { 
    local acmd list akind
    local flag=0
    
    printf "%s├─ Examining aliases to detect overridden commands:\n" "$indent"

    while IFS= read -r acmd; do
        mapfile -t list < <(type -at "$acmd")

        # Deduplicate results
        declare -A seen=()
        local uniq=()
        for akind in "${list[@]}"; do
            [[ ${seen[$akind]} ]] && continue
            uniq+=("$akind")
            seen[$akind]=1
        done

        for akind in "${uniq[@]}"; do
            case "$akind" in
                builtin)
                    printf "%s    ↳ Alias ${YELLOW}%s${RESET} overrides a builtin of the same name.\n" "$indent" "$acmd"
                    flag=1 ;;
                file)
                    printf "%s    ↳ Alias ${YELLOW}%s${RESET} overrides at least one external command of the same name.\n" "$indent" "$acmd"
                    flag=1 ;;
            esac
        done
    done < <(alias | sed -E 's/^alias ([^=]+)=.*/\1/')

    if (( flag == 0 )); then
        printf "%s    ↳ ${CYAN}No command or builtin is overridden.${RESET}\n" "$indent"
    fi
}

#------------------------------------------------------------------------
# Function: _ca_function_override                         
# Purpose : list all functions that override a command
#------------------------------------------------------------------------
_ca_function_override() { 
    local funcmd kind kinds 
    local func_flag=0

    printf "%s├─ Examining functions to detect overridden commands:\n" "$indent"

    # Get list of function names
    while read -r funcmd; do
        mapfile -t kinds < <(type -at "$funcmd")

        for kind in "${kinds[@]}"; do
            case "$kind" in
                alias)
                    printf "%s    ↳ Function ${YELLOW}%s${RESET} overrides an alias of the same name.\n" "$indent" "$funcmd"
                    func_flag=1
                    ;;
                keyword)
                    printf "%s    ↳ Function ${YELLOW}%s${RESET} conflicts with a shell keyword of the same name (keyword takes precedence).\n" "$indent" "$funcmd"
                    func_flag=1
                    ;;
                builtin)
                    printf "%s    ↳ Function ${YELLOW}%s${RESET} overrides a builtin of the same name.\n" "$indent" "$funcmd"
                    func_flag=1
                    ;;
                file)
                    printf "%s    ↳ Function ${YELLOW}%s${RESET} overrides at least one external command of the same name.\n" "$indent" "$funcmd"
                    func_flag=1
                    ;;
            esac
        done
    done < <(declare -F | awk '{print $3}')

    if [[ $func_flag -eq 0 ]]; then
        printf "%s    ↳ No command or builtin is overridden.\n" "$indent"
    fi
}

#------------------------------------------------------------------------
# Function: _ca_builtin_override
# Purpose : list builtins that are disabled and note if external commands replace them
#------------------------------------------------------------------------
_ca_builtin_override() {
    printf "%s├─ Examining disabled builtins to identify any replacement commands:\n" "$indent"

    local b disabled=()

    # Collect disabled builtins
    while read -r b; do
        disabled+=("${b#enable -n }")
    done < <(enable -a | grep '^enable -n ')

    if (( ${#disabled[@]} == 0 )); then
        printf "%s    ↳ No builtins are disabled.\n" "$indent"
        return
    fi

    local name
    for name in "${disabled[@]}"; do
        printf "%s    ↳ Builtin ${YELLOW}%s${RESET} is DISABLED.\n" "$indent" "$name"

        # 1. Alias replacement?
        if alias "$name" &>/dev/null; then
            adef=$(allias "$name")
            printf "%s       • Alias ${YELLOW}'%s' -- '%s'${RESET} now replaces the builtin.\n" "$indent" "$name" "$adef"
            continue
        fi

        # 2. Function replacement?
        if declare -F "$name" &>/dev/null; then
            printf "%s       • Function ${YELLOW}'%s'${RESET} now replaces the builtin.\n" "$indent" "$name"
            continue
        fi

        # 3. External command replacement?
        if command -v "$name" &>/dev/null; then
            local newpath=$(command -v "$name")
            printf "%s       • External command ${YELLOW}'%s' - '%s'${RESET} now replaces the builtin.\n" "$indent" "$name" "$newpath"
        else
            printf "%s       • No alias, function, or command replaces ${CYAN}'%s'${RESET}.\n" "$indent" "$name"
        fi
    done
}

#------------------------------------------------------------------------
# End of script
